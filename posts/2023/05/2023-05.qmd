---
title: "2023 Day 5"
subtitle: "If You Give A Seed A Fertilizer"
date: 2024-01-20
categories: [python, medium, dynamic programming]
draft: false
knitr:
  opts_chunk: 
    comment: "#>"
    collapse: true
problem_url: "https://adventofcode.com/2023/day/5"
description: "Medium difficulty intervals puzzle."
---

Ho ho ho, fellow adventurers!

In [Advent of Code day 5]({{< meta problem_url >}}) [Intro]

First, we'll read the input.
```{python}
with open('input.txt', "r") as f:
    lines = f.read().splitlines()
```

## Part 1 <small class="text-body-secondary">[Part 1 Title]</small>

::::: {.p-0 style="min-width: fit-content;"}

```{=html}
<div class="card border-secondary mb-3 mx-auto">
  <div class="card-body p-3 m-1 pb-0 mb-0">
    <h4 class="card-title mt-0">Task 1</h4>
```

Calculate the <b class='fw-bold' style='color: #91672C;'>sum</b> of scores of each card as one for the first <b class='fw-bold' style='color: #2F7E4A;'>match</b> and double for each subsequent <b class='fw-bold' style='color: #2F7E4A;'>match</b>.

<h6 class="card-subtitle text-muted">Example</h6>

```{r dev="svg"}
#| dpi: 216
#| code-fold: true
#| code-summary: "Figure Source"
#| warning: false
library(tidyverse)

#| fig-width: 5
#| fig-height: 4
text <- "seeds: 79 14 55 13

seed-to-soil map:
50 98 2
52 50 48

soil-to-fertilizer map:
0 15 37
37 52 2
39 0 15

fertilizer-to-water map:
49 53 8
0 11 42
42 0 7
57 7 4

water-to-light map:
88 18 7
18 25 70

light-to-temperature map:
45 77 23
81 45 19
68 64 13

temperature-to-humidity map:
0 69 1
1 0 69

humidity-to-location map:
60 56 37
56 93 4"

lines <- str_split_1(text, "\n\n")

seeds <-
  lines[[1]] |>
  str_extract_all("\\d+", simplify = TRUE) |>
  as.numeric()

steps <-
  lines[-1] |>
  map(read_lines) |>
  map(\(.) {
    .[-1] |>
      str_extract_all("\\d+", simplify = TRUE) |>
      as_tibble() |>
      set_names(c("dest_start", "source_start", "range_len")) |>
      mutate(across(everything(), as.numeric))
  })

get_path <- function(seed) {
  value <- seed
  step <- 1
  path <- list()
  
  while (step <= length(steps)) {
    dest <-
      steps[[step]] |>
      mutate(
        is_valid = value >= source_start & value < source_start + range_len,
        dest = dest_start + value - source_start
      ) |>
      filter(value >= source_start & value < source_start + range_len) |>
      pull(dest)
    
    new_value <- c(dest, value)[1]
    path <- bind_rows(
      path,
      tibble(
        x = value,
        xend = new_value,
        y = 9 - step,
        yend = y - 1
      )
    )
    value = new_value
    step <- step + 1
  }
  path
}

paths <-
  seeds |>
  map(get_path) |>
  list_rbind()

plot_df <-
  steps |>
  list_rbind(names_to = "step") |>
  mutate(
    y = 9 - step,
    yend = y - 1,
    x = map2(source_start, range_len, \(start, range) start + seq_len(range) - 1),
    xend = map2(dest_start, range_len, \(start, range) start + seq_len(range) - 1)
  ) |>
  unnest()

points <-
  bind_rows(
    paths |> select(x, y),
    paths |> select(x = xend, y = yend)
  ) |>
  mutate(
    col = case_when(
      y == 8 ~ "#2F7E4A",
      y == 1 & x == 35 ~ "#91672C",
      TRUE ~ "#1577A0"
    ),
    size = ifelse(col == "#1577A0", 1.1, 3)
  )

p <-
  ggplot(plot_df, aes(x, y, xend = xend, yend = yend)) +
  geom_segment(alpha = 0.5, col = "#969696") +
  geom_segment(data = paths, col = "#1577A0") +
  geom_point(
    data = points,
    mapping = aes(x, y, col = I(col), size = I(size), xend = NULL, yend = NULL)
  ) +
  scale_y_continuous(
    breaks = seq_len(8),
    labels = rev(c("Seed", "Soil", "Fertilizer", "Water", "Light", "Temperature", "Humidity", "Location"))
  ) +
  theme_void() +
  theme(
    axis.text.y = element_text(margin = margin(r = 0.8 * 11 / 2), hjust = 1)
  )

p
```

```{=html}
  </div>
</div>
```

:::::

<div style="clear: both;"></div> 

Part 1 is straightforward. We need to find the overlap of two sets and do some basic scoring.

We can parse out the left and right numbers into `set`s. Then the number of wins is just the length of the intersection of those sets.

```{python}
#| eval: false
import re


cards = [[set(re.findall(r'\d+', side)) for side in line.split(':')[1].split('|')] for line in lines]
n_wins = [len(have.intersection(want)) for have, want in cards]
```

The score can be calculated as
$$
\begin{equation}
\text{score}(\text{wins})=
    \begin{cases}
        2^{\text{wins} - 1} & \text{if wins} \gt 0\\
        0 & \text{otherwise}
    \end{cases}
\end{equation}
$$

```{python}
#| eval: false
answer1 = sum(2**(n - 1) for n in n_wins if n > 0)
```

Putting it all together
```{python}
#
```

```{=html}
<div class="card border-info mb-3 mx-auto">
  <div class="card-header text-white bg-info">Key Points</div>
  <div class="card-body p-1">
    <p class="card-text">
```

* Parse the left and right numbers into `set`s
* Calculate the number of wins as the length of the intersection of those `set`s
* Calculate the score based off the number of wins

```{=html}
    </p>
  </div>
</div>
```


## Part 2 <small class="text-body-secondary">Cutting Corners Caching Card Copies</small>

::::: {.p-0 style="min-width: fit-content;"}

:::: {.pe-4}
```{=html}
<div class="card border-secondary mb-3 mx-auto">
  <div class="card-body p-3 m-1 pb-0 mb-0">
    <h4 class="card-title mt-0">Task 2</h4>
```

Each <b class='fw-bold' style='color: #2F7E4A;'>match</b> wins copies of subsequent cards. Count all <mark class='fw-bold' style='background-color: #FFF3BF'>original cards</mark> and <mark class='fw-bold' style='background-color: #EDECFF;'>won copies</mark> to find the number of <b class='fw-bold' style='color: #91672C;'>total cards</b>.


<h6 class="card-subtitle text-muted">Example</h6>

In this example, there are <mark class='fw-bold' style='background-color: #FFF3BF'>6 original cards</mark> and <mark class='fw-bold' style='background-color: #EDECFF;'>24 won copies</mark> for a total of <b class='fw-bold' style='color: #91672C;'>30</b> cards.


```{r}
```

```{=html}
  </div>
</div>
```
::::
:::::

The example can be solved by constructing the graph and counting the number of nodes. However, our full input would have **millions** of nodes - that wouldn't be very efficient.

### Spotting Superfluous Subproblems Saves Seconds

To tackle this problem, we first need to identify that this is a **dynamic programming** problem. How do we know that?

Well, how many subproblems do we need to solve in the example? Each node is a subproblem so there are `30` **subproblems**.

Now, how many **distinct subproblems** are there? That is, how many distinct nodes are there? Only `6`!

This leads us to conclude that this is a dynamic programming problem as there are [**overlapping subproblems**]{.underline}.

### From Brute Force to Brilliance

So how can dynamic programming help us?

Rather than solving all `30` **subproblems**, we can just solve the `6` **distinct subproblems** and reuse those results. This saves us from repeating work we've already done.

### Effortless Efficiency

So now we know we need to use **dynamic programming**, but how do we do that? The thing is, unlike specific algorithms with defined steps, dynamic programming is a broad paradigm. There are multiple different ways to implement it.

I'm going to share the *easiest* and *most intuitive* way to implement dynamic programming: [**recursion with memoisation**]{.underline}

#### Step 1: Recursion

Write the most naive and inefficient recursive solution you can come up with. Remember that a recursive function has two components:

1. Base case
2. Recursive case

```{python}
#| eval: false
def count_scratchcards(i):
    # 1. Base case: If we win a card that doesn't exist
    if i > len(n_wins):
        return 0
  
    # 2. Recursive case: The number of cards is this card (1) plus the sum of the next n cards
    return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))
```

#### Step 2: Memoisation

Our recursive function essentially counts every node in the graph. To make it only execute computations for **distinct nodes** we just **memoise** the function! Memoisation is caching the results of a pure function.

Luckily, this is just one line in python.

```{python}
#| eval: false
import functools


@functools.cache # Memoisation
def count_scratchcards(i):
    # 1. Base case: If we win a card that doesn't exist
    if i > len(n_wins):
        return 0
  
    # 2. Recursive case: The number of cards is this card (1) plus the sum of the next n cards
    return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))
```


Here's what this looks like showing <mark class='fw-bold' style='background-color: #EDECFF'>calculated</mark> and <mark class='fw-bold' style='background-color: #FFADAD'>cached</mark> nodes.

<div style="clear: both;"></div> 

### Scratchy Solution Summarised

Our final answer sums up all of the original cards.

```{python}
#
```

```{=html}
<div class="card border-info mb-3 mx-auto">
  <div class="card-header text-white bg-info">Key Points</div>
  <div class="card-body p-1">
    <p class="card-text">
```

* Uses **dynamic programming** via [**recursion with memoisation**]{.underline}
* `count_scratchcards` naively recursively counts the `i`^th^ card
  * **Base case:** If `i` exceeds the number of cards then there are `0` cards
  * **Recursive case:** `1` (for the current card) plus the sum of subsequent cards
* `@functools.cache` **memoises** the function meaning it executes only a few hundred times instead of millions

```{=html}
    </p>
  </div>
</div>
```


{{< include ../../_button_footer.qmd >}}
