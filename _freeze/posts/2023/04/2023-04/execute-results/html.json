{
  "hash": "43efdb98ca5448dfb99efc7db18dcaed",
  "result": {
    "markdown": "---\ntitle: \"2023 Day 4\"\nsubtitle: \"Scratchcards\"\ndate: 2024-01-06\ncategories: [python, medium, dynamic programming]\ndraft: false\nknitr:\n  opts_chunk: \n    comment: \"#>\"\n    collapse: true\nproblem_url: \"https://adventofcode.com/2023/day/4\"\ndescription: \"Medium difficulty dynamic programming puzzle.\"\nmermaid:\n  theme: neutral\n---\n\n\nHo ho ho, fellow adventurers!\n\nIn [Advent of Code day 4]({{< meta problem_url >}}) we must convince an elf to lend us his boat by helping him decipher his scratchcards.\n\nThis puzzle propels us into the exciting world of **dynamic programming**, a technique for efficiently solving problems with **overlapping subproblems**. It's our secret weapon against repetitive calculations!\n\nEven if you're new to this, fear not! I'll share an easy intuitive approach that will work with almost any **dynamic programming** challenge.\n\nFirst, we'll read the input.\n\n::: {.cell}\n\n```{.python .cell-code}\nwith open('input.txt', \"r\") as f:\n    lines = f.read().splitlines()\n```\n:::\n\n\n## Part 1 <small class=\"text-body-secondary\">Multiplicative Match Mayhem</small>\n\n::: {.hidden}\n$$\n\\newcommand{\\grey}[1]{\\normalsize\\color{##969696}#1\\normalsize}\n$$\n\n$$\n\\newcommand{\\score}[1]{\\phantom{xxxxxxxx}\\llap{\\grey{#1}}}\n$$\n\n$$\n\\newcommand{\\plus}{\\smash{\\lower{0.5pc}\\color{#969696}{+}}}\n$$\n\n$$\n\\newcommand{\\card}[1]{\\text{Card #1: }}\n$$\n\n$$\n\\newcommand{\\num}[1]{\\large\\phantom{\\textbf{\\;1\\;\\;}}\\llap{\\text{\\;#1}}}\n$$\n\n$$\n\\newcommand{\\match}[1]{\\color{##2F7E4A}\\large\\phantom{\\textbf{\\;1\\;\\;}}\\llap{\\;\\textbf{#1}}\\color{##55595C}\\normalsize}\n$$\n\n$$\n\\newcommand{\\wins}[1]{\\phantom{xxx}\\llap{\\grey{\\text{#1}}}}\n$$\n\n<!-- Hidden PNG Mermaid chart for the preview image -->\n\n```{mermaid}\n%%| mermaid-format: png\n%%{\n  init: {\n    'theme': 'base',\n    'themeVariables': {\n      'primaryColor': '#55595c',\n      'primaryTextColor': '#55595c',\n      'primaryBorderColor': '#C2C2C2',\n      'lineColor': '#C2C2C2',\n      'secondaryColor': '#C2C2C2',\n      'tertiaryColor': '#fff',\n      'background': '#FFFFFF',\n      'mainBkg': '#FFFFFF',\n      'clusterBkg': '#ededed',\n      'fontFamily': 'Nunito Sans'\n    },\n    'flowchart': {\n      'nodeSpacing': 15,\n      'rankSpacing': 50\n    }\n  }\n}%%\nflowchart LR\n  A[Card 1]:::starting --> A1[Card 2]\n  A[Card 1] --> A2[Card 3]\n  A[Card 1] --> A3[Card 4]\n  A[Card 1] --> A4[Card 5]\n  A1 --> A11[Card 3]\n  A1 --> A12[Card 4]\n  A2 --> A21[Card 4]\n  A2 --> A22[Card 5]\n  A3[Card 4] --> A31[Card 5]\n  A11 --> A111[Card 4]\n  A11 --> A112[Card 5]\n  A12[Card 4] --> A121[Card 5]\n  A21[Card 4] --> A211[Card 5]\n  A111[Card 4] --> A1111[Card 5]\n\n  B[Card 2]:::starting --> B1[Card 3]\n  B[Card 2] --> B2[Card 4]\n  B1 --> B11[Card 4]\n  B1 --> B12[Card 5]\n  B11[Card 4] --> B111[Card 5]\n  B2 --> B21[Card 5]\n  \n  C[Card 3]:::starting --> C1[Card 4]\n  C[Card 3] --> C2[Card 5]\n  C1[Card 4] --> C11[Card 5]\n  \n  D[Card 4]:::starting --> D1[Card 5]\n  E[Card 5]:::starting\n  F[Card 6]:::starting\n  classDef default fill:#EDECFF\n  classDef starting fill:#FFF3BF\n```\n\n:::\n\n::::: {.p-0 style=\"min-width: fit-content;\"}\n\n\n```{=html}\n<div class=\"card border-secondary mb-3 mx-auto\">\n  <div class=\"card-body p-3 m-1 pb-0 mb-0\">\n    <h4 class=\"card-title mt-0\">Task 1</h4>\n```\n\n\nCalculate the <b class='fw-bold' style='color: #91672C;'>sum</b> of scores of each card as one for the first <b class='fw-bold' style='color: #2F7E4A;'>match</b> and double for each subsequent <b class='fw-bold' style='color: #2F7E4A;'>match</b>.\n\n<h6 class=\"card-subtitle text-muted\">Example</h6>\n\n$$\n\\begin{aligned}\n&\\card{1}\\num{41}\\match{48}\\match{83}\\match{86}\\match{17}\\;|\\match{83}\\match{86}\\num{ 6}\\num{31}\\match{17}\\num{ 9}\\match{48}\\num{53}&\\wins{4 wins}&&\\score{1 \\times 2 \\times 2 \\times 2}\\plus\\\\\n&\\card{2}\\num{13}\\match{32}\\num{20}\\num{16}\\match{61}\\;|\\match{61}\\num{30}\\num{68}\\num{82}\\num{17}\\match{32}\\num{24}\\num{19}&\\wins{2 wins}&&\\score{1 \\times 2}\\plus\\\\\n&\\card{3}\\match{ 1}\\match{21}\\num{53}\\num{59}\\num{44}\\;|\\num{69}\\num{82}\\num{63}\\num{72}\\num{16}\\match{21}\\num{14}\\match{ 1}&\\wins{2 wins}&&\\score{1 \\times 2}\\plus\\\\\n&\\card{4}\\num{41}\\num{92}\\num{73}\\match{84}\\num{69}\\;|\\num{59}\\match{84}\\num{76}\\num{51}\\num{58}\\num{ 5}\\num{54}\\num{83}&\\wins{1 wins}&&\\score{1}\\plus\\\\\n&\\card{5}\\num{87}\\num{83}\\num{26}\\num{28}\\num{32}\\;|\\num{88}\\num{30}\\num{70}\\num{12}\\num{93}\\num{22}\\num{82}\\num{36}&\\wins{0 wins}&&\\score{0}\\plus\\\\\n&\\card{6}\\num{31}\\num{18}\\num{13}\\num{56}\\num{72}\\;|\\num{74}\\num{77}\\num{10}\\num{23}\\num{35}\\num{67}\\num{36}\\num{11}&\\wins{0 wins}&&\\score{0}\\llap{\\lower{0.4pc}\\underline{\\phantom{\\large{\\textbf{13}}}}}\\phantom{\\plus}\\\\\n& & && \\color{#91672C}\\large{\\textbf{13}}\\normalsize\\phantom{\\plus}\n\\end{aligned}\n$$\n\n\n```{=html}\n  </div>\n</div>\n```\n\n\n:::::\n\n<div style=\"clear: both;\"></div> \n\nPart 1 is straightforward. We need to find the overlap of two sets and do some basic scoring.\n\nWe can parse out the left and right numbers into `set`s. Then the number of wins is just the length of the intersection of those sets.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport re\n\n\ncards = [[set(re.findall(r'\\d+', side)) for side in line.split(':')[1].split('|')] for line in lines]\nn_wins = [len(have.intersection(want)) for have, want in cards]\n```\n:::\n\n\nThe score can be calculated as\n$$\n\\begin{equation}\n\\text{score}(\\text{wins})=\n    \\begin{cases}\n        2^{\\text{wins} - 1} & \\text{if wins} \\gt 0\\\\\n        0 & \\text{otherwise}\n    \\end{cases}\n\\end{equation}\n$$\n\n\n::: {.cell}\n\n```{.python .cell-code}\nanswer1 = sum(2**(n - 1) for n in n_wins if n > 0)\n```\n:::\n\n\nPutting it all together\n\n::: {.cell}\n\n```{.python .cell-code}\nimport re\n\n\ncards = [[set(re.findall(r'\\d+', side)) for side in line.split(':')[1].split('|')] for line in lines]\nn_wins = [len(have.intersection(want)) for have, want in cards]\nanswer1 = sum(2**(n - 1) for n in n_wins if n > 0)\nprint(answer1)\n#> 13\n```\n:::\n\n```{=html}\n<div class=\"card border-info mb-3 mx-auto\">\n  <div class=\"card-header text-white bg-info\">Key Points</div>\n  <div class=\"card-body p-1\">\n    <p class=\"card-text\">\n```\n\n\n* Parse the left and right numbers into `set`s\n* Calculate the number of wins as the length of the intersection of those `set`s\n* Calculate the score based off the number of wins\n\n\n```{=html}\n    </p>\n  </div>\n</div>\n```\n\n\n\n## Part 2 <small class=\"text-body-secondary\">Cutting Corners Caching Card Copies</small>\n\n::::: {.p-0 style=\"min-width: fit-content;\"}\n\n:::: {.pe-4}\n\n```{=html}\n<div class=\"card border-secondary mb-3 mx-auto\">\n  <div class=\"card-body p-3 m-1 pb-0 mb-0\">\n    <h4 class=\"card-title mt-0\">Task 2</h4>\n```\n\n\nEach <b class='fw-bold' style='color: #2F7E4A;'>match</b> wins copies of subsequent cards. Count all <mark class='fw-bold' style='background-color: #FFF3BF'>original cards</mark> and <mark class='fw-bold' style='background-color: #EDECFF;'>won copies</mark> to find the number of <b class='fw-bold' style='color: #91672C;'>total cards</b>.\n\n\n<h6 class=\"card-subtitle text-muted\">Example</h6>\n\nIn this example, there are <mark class='fw-bold' style='background-color: #FFF3BF'>6 original cards</mark> and <mark class='fw-bold' style='background-color: #EDECFF;'>24 won copies</mark> for a total of <b class='fw-bold' style='color: #91672C;'>30</b> cards.\n\n$$\n\\begin{aligned}\n&\\card{1}\\num{41}\\match{48}\\match{83}\\match{86}\\match{17}\\;|\\match{83}\\match{86}\\num{ 6}\\num{31}\\match{17}\\num{ 9}\\match{48}\\num{53}&&\\grey{\\text{Wins cards 2, 3, 4, \\& 5}}\\\\\n&\\card{2}\\num{13}\\match{32}\\num{20}\\num{16}\\match{61}\\;|\\match{61}\\num{30}\\num{68}\\num{82}\\num{17}\\match{32}\\num{24}\\num{19}&&\\grey{\\text{Wins cards 3 \\& 4}}\\\\\n&\\card{3}\\match{ 1}\\match{21}\\num{53}\\num{59}\\num{44}\\;|\\num{69}\\num{82}\\num{63}\\num{72}\\num{16}\\match{21}\\num{14}\\match{ 1}&&\\grey{\\text{Wins cards 4 \\& 5}}\\\\\n&\\card{4}\\num{41}\\num{92}\\num{73}\\match{84}\\num{69}\\;|\\num{59}\\match{84}\\num{76}\\num{51}\\num{58}\\num{ 5}\\num{54}\\num{83}&&\\grey{\\text{Wins card 5}}\\\\\n&\\card{5}\\num{87}\\num{83}\\num{26}\\num{28}\\num{32}\\;|\\num{88}\\num{30}\\num{70}\\num{12}\\num{93}\\num{22}\\num{82}\\num{36}&&\\\\\n&\\card{6}\\num{31}\\num{18}\\num{13}\\num{56}\\num{72}\\;|\\num{74}\\num{77}\\num{10}\\num{23}\\num{35}\\num{67}\\num{36}\\num{11}&&\\\\\n\\end{aligned}\n$$\n\n:::{.d-flex .justify-content-center}\n\n```{mermaid}\n%%{\n  init: {\n    'theme': 'base',\n    'themeVariables': {\n      'primaryColor': '#55595c',\n      'primaryTextColor': '#55595c',\n      'primaryBorderColor': '#C2C2C2',\n      'lineColor': '#C2C2C2',\n      'secondaryColor': '#C2C2C2',\n      'tertiaryColor': '#fff',\n      'background': '#FFFFFF',\n      'mainBkg': '#FFFFFF',\n      'clusterBkg': '#ededed',\n      'fontFamily': 'Nunito Sans'\n    },\n    'flowchart': {\n      'nodeSpacing': 15,\n      'rankSpacing': 50\n    }\n  }\n}%%\nflowchart LR\n  A[Card 1]:::starting --> A1[Card 2]\n  A[Card 1] --> A2[Card 3]\n  A[Card 1] --> A3[Card 4]\n  A[Card 1] --> A4[Card 5]\n  A1 --> A11[Card 3]\n  A1 --> A12[Card 4]\n  A2 --> A21[Card 4]\n  A2 --> A22[Card 5]\n  A3[Card 4] --> A31[Card 5]\n  A11 --> A111[Card 4]\n  A11 --> A112[Card 5]\n  A12[Card 4] --> A121[Card 5]\n  A21[Card 4] --> A211[Card 5]\n  A111[Card 4] --> A1111[Card 5]\n\n  B[Card 2]:::starting --> B1[Card 3]\n  B[Card 2] --> B2[Card 4]\n  B1 --> B11[Card 4]\n  B1 --> B12[Card 5]\n  B11[Card 4] --> B111[Card 5]\n  B2 --> B21[Card 5]\n  \n  C[Card 3]:::starting --> C1[Card 4]\n  C[Card 3] --> C2[Card 5]\n  C1[Card 4] --> C11[Card 5]\n  \n  D[Card 4]:::starting --> D1[Card 5]\n  E[Card 5]:::starting\n  F[Card 6]:::starting\n  classDef default fill:#EDECFF\n  classDef starting fill:#FFF3BF\n```\n\n:::\n\n\n```{=html}\n  </div>\n</div>\n```\n\n::::\n:::::\n\nThe example can be solved by constructing the graph and counting the number of nodes. However, our full input would have **millions** of nodes - that wouldn't be very efficient.\n\n### Spotting Superfluous Subproblems Saves Seconds\n\nTo tackle this problem, we first need to identify that this is a **dynamic programming** problem. How do we know that?\n\nWell, how many subproblems do we need to solve in the example? Each node is a subproblem so there are `30` **subproblems**.\n\nNow, how many **distinct subproblems** are there? That is, how many distinct nodes are there? Only `6`!\n\nThis leads us to conclude that this is a dynamic programming problem as there are [**overlapping subproblems**]{.underline}.\n\n### From Brute Force to Brilliance\n\nSo how can dynamic programming help us?\n\nRather than solving all `30` **subproblems**, we can just solve the `6` **distinct subproblems** and reuse those results. This saves us from repeating work we've already done.\n\n### Effortless Efficiency\n\nSo now we know we need to use **dynamic programming**, but how do we do that? The thing is, unlike specific algorithms with defined steps, dynamic programming is a broad paradigm. There are multiple different ways to implement it.\n\nI'm going to share the *easiest* and *most intuitive* way to implement dynamic programming: [**recursion with memoisation**]{.underline}\n\n#### Step 1: Recursion\n\nWrite the most naive and inefficient recursive solution you can come up with. Remember that a recursive function has two components:\n\n1. Base case\n2. Recursive case\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef count_scratchcards(i):\n    # 1. Base case: If we win a card that doesn't exist\n    if i > len(n_wins):\n        return 0\n  \n    # 2. Recursive case: The number of cards is this card (1) plus the sum of the next n cards\n    return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))\n```\n:::\n\n\n#### Step 2: Memoisation\n\nOur recursive function essentially counts every node in the graph. To make it only execute computations for **distinct nodes** we just **memoise** the function! Memoisation is caching the results of a pure function.\n\nLuckily, this is just one line in python.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport functools\n\n\n@functools.cache # Memoisation\ndef count_scratchcards(i):\n    # 1. Base case: If we win a card that doesn't exist\n    if i > len(n_wins):\n        return 0\n  \n    # 2. Recursive case: The number of cards is this card (1) plus the sum of the next n cards\n    return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))\n```\n:::\n\n\n\nHere's what this looks like showing <mark class='fw-bold' style='background-color: #EDECFF'>calculated</mark> and <mark class='fw-bold' style='background-color: #FFADAD'>cached</mark> nodes.\n\n:::{.d-flex .justify-content-center}\n\n```{mermaid}\n%%{\n  init: {\n    'theme': 'base',\n    'themeVariables': {\n      'primaryColor': '#55595c',\n      'primaryTextColor': '#55595c',\n      'primaryBorderColor': '#C2C2C2',\n      'lineColor': '#C2C2C2',\n      'secondaryColor': '#C2C2C2',\n      'tertiaryColor': '#fff',\n      'background': '#FFFFFF',\n      'mainBkg': '#FFFFFF',\n      'clusterBkg': '#ededed',\n      'fontFamily': 'Nunito Sans'\n    },\n    'flowchart': {\n      'nodeSpacing': 15,\n      'rankSpacing': 50\n    }\n  }\n}%%\nflowchart LR\n  A[Card 1] --> A1[Card 2]\n  A[Card 1] --> A2[Card 3]:::cached\n  A[Card 1] --> A3[Card 4]:::cached\n  A[Card 1] --> A4[Card 5]:::cached\n  A1 --> A11[Card 3]\n  A1 --> A12[Card 4]:::cached\n  A11 --> A111[Card 4]\n  A11 --> A112[Card 5]:::cached\n  A111[Card 4] --> A1111[Card 5]\n\n  X:::space\n  B[Card 2]:::cached\n  C[Card 3]:::cached  \n  D[Card 4]:::cached\n  E[Card 5]:::cached\n  F[Card 6]\n  classDef default fill:#EDECFF\n  classDef cached fill:#FFADAD\n  classDef space fill:white,color:white,stroke:white\n```\n\n:::\n\n<div style=\"clear: both;\"></div> \n\n### Scratchy Solution Summarised\n\nOur final answer sums up all of the original cards.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport functools\n\n\n@functools.cache\ndef count_scratchcards(i):\n    if i > len(n_wins):\n        return 0\n    return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))\n\n\nanswer2 = sum(count_scratchcards(i) for i in range(len(n_wins)))\nprint(answer2)\n#> 30\n```\n:::\n\n```{=html}\n<div class=\"card border-info mb-3 mx-auto\">\n  <div class=\"card-header text-white bg-info\">Key Points</div>\n  <div class=\"card-body p-1\">\n    <p class=\"card-text\">\n```\n\n\n* Uses **dynamic programming** via [**recursion with memoisation**]{.underline}\n* `count_scratchcards` naively recursively counts the `i`^th^ card\n  * **Base case:** If `i` exceeds the number of cards then there are `0` cards\n  * **Recursive case:** `1` (for the current card) plus the sum of subsequent cards\n* `@functools.cache` **memoises** the function meaning it executes only a few hundred times instead of millions\n\n\n```{=html}\n    </p>\n  </div>\n</div>\n```\n\n\n## Stocking Stuffers <small class=\"text-body-secondary\">Dynamic Programming for Dummies</small>\n\n**Dynamic programming** involves two steps:\n\n 1. Breaking a problem down into **subproblems**.\n 2. Recognising that many of these subproblems are **equivalent**. As we solve each subproblem, we record its answer. When we encounter a subproblem again, we simply retrieve its stored solution, avoiding wasteful recalculations.\n\n::: {.callout-note}\nWhen you have `1` without `2`, you are employing **divide and conquer** and _not_ dynamic programming. E.g. quicksort and binary search.\n:::\n\nThis can be implemented in two ways:\n\n 1. **Top-down**: Starts with the whole problem, breaks it down into smaller subproblems, and recursively solves them, storing solutions to reuse as needed.\n 2. **Bottom-up**: Starts with the smallest subproblems, solves them, and builds up to the larger problem, iteratively combining solutions until the whole problem is solved.\n\nLet's use the most common example, the **Fibonacci Numbers**. They're defined as\n$$\n\\begin{equation}\nF_n =\n    \\begin{cases}\n        1 & \\text{if } n = 1 \\text{ or } n = 2\\\\\n        F_{n-1} + F_{n-2} & n \\gt 2\n    \\end{cases}\n\\end{equation}\n$$\n\n### Top-Down\nThe easiest way to implement top-down dynamic programming is [**recursion with memoisation**]{.underline}\n\nWriting the problem recursively starts with the whole problem, breaks it down into smaller subproblems. Memoisation stores the solutions and reuses them as needed.\n\nThe mathematical definition directly translates to a recursive definition in python. Slap a `@functools.cache` on that bad boy and you're done!\n\n\n::: {.cell}\n\n```{.python .cell-code}\n@functools.cache\ndef fib(n):\n  if n in (1, 2):\n    return 1\n  return fib(n - 1) + fib(n - 2)\n```\n:::\n\n\n### Bottom-Up\nWith bottom-up, we typically have an array that is conventionally called `dp`. We start with the smallest subproblem and build from there (`fib(1)`, `fib(2)`, `...`, `fib(n)`).\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef fib(n):\n  dp = [0] * (n + 1)\n  dp[1] = 1\n\n  for i in range(2, n + 1):\n    dp[i] = dp[i - 1] + dp[i - 2]\n\n  return dp[n]\n```\n:::\n::: {.cell}\n\n:::\n\n```{=html}\n<!-- Buttons -->\n<div class=\"d-grid gap-2 d-md-flex justify-content-md-end\">\n\n  <!-- Problem Button -->\n  <a type=\"button\" class=\"btn btn-secondary\" href=\"{{< meta problem_url >}}\" role=\"button\">\n    <i class=\"bi bi-box-arrow-up-right\"></i> Problem\n  </a>\n\n  <!-- Input Button -->\n  <button type=\"button\" class=\"btn btn-secondary\" data-bs-toggle=\"modal\" data-bs-target=\"#inputModal\">\n    <i class=\"bi bi-file-earmark-text\"></i> Input\n  </button>\n\n  <!-- Solution Modal Button -->\n  <button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#solutionModal\">\n    <i class=\"bi bi-code-slash\"></i> Full Solution\n  </button>\n\n</div>\n\n\n<!-- Input Modal -->\n<div class=\"modal fade\" id=\"inputModal\" tabindex=\"-1\" aria-labelledby=\"inputModalLabel\" aria-hidden=\"true\">\n<div class=\"modal-dialog modal-dialog-scrollable modal-xl\">\n<div class=\"modal-content\">\n<div class=\"modal-header\">\n  <h5 class=\"modal-title\" id=\"inputModalLabel\">{{< meta title >}} Input</h5>\n  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n</div>\n<div class=\"modal-body\">\n```\n::: {.cell file='input.txt'}\n\n```{.r .cell-code}\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\nCard 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\nCard 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\nCard 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\nCard 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\nCard 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\n```\n:::\n\n```{=html}\n</div>\n<div class=\"modal-footer\">\n</div>\n</div>\n</div>\n</div>\n\n\n<!-- Solution Modal -->\n<div class=\"modal fade\" id=\"solutionModal\" tabindex=\"-1\" aria-labelledby=\"solutionModalLabel\" aria-hidden=\"true\">\n<div class=\"modal-dialog modal-dialog-scrollable modal-xl\">\n<div class=\"modal-content\">\n<div class=\"modal-header\">\n  <h5 class=\"modal-title\" id=\"solutionModalLabel\">{{< meta title >}} Full Solution</h5>\n  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n</div>\n<div class=\"modal-body\">\n```\n::: {.cell file='solution.py'}\n\n```{.r .cell-code}\nimport functools\nimport re\n\n\nwith open(r'input.txt', \"r\") as f:\n    lines = f.read().splitlines()\n\n\ncards = [[set(re.findall(r'\\d+', side)) for side in line.split(':')[1].split('|')] for line in lines]\nn_wins = [len(have.intersection(want)) for have, want in cards]\nanswer1 = sum(2**(n - 1) for n in n_wins if n > 0)\nprint(answer1)\n\n\n# Part 2\n@functools.cache\ndef count_scratchcards(i):\n  if i > len(n_wins):\n    return 0\n  return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))\n\n\nanswer2 = sum(count_scratchcards(i) for i in range(len(n_wins)))\nprint(answer2)\n```\n:::\n\n```{=html}\n</div>\n<div class=\"modal-footer\">\n<small><i>Execution took 0.01 seconds</i></small>\n</div>\n</div>\n</div>\n</div>\n```\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}