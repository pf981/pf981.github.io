{
  "hash": "adc200b5097f75890d081eefd60fa585",
  "result": {
    "markdown": "---\ntitle: \"2023 Day 5\"\nsubtitle: \"If You Give A Seed A Fertilizer\"\ndate: 2024-03-29\ncategories: [python, medium, intervals]\ndraft: false\nknitr:\n  opts_chunk: \n    comment: \"#>\"\n    collapse: true\nproblem_url: \"https://adventofcode.com/2023/day/5\"\ndescription: \"Medium difficulty intervals puzzle.\"\n---\n\n::: {.cell}\n\n:::\n\n\nHo ho ho, fellow adventurers!\n\nIn [Advent of Code day 5]({{< meta problem_url >}}) we're tasked with helping the gardener plant seeds and optimise food production.\n\nThis puzzle introduces us to interval mapping. We're given a series of maps that define how values transition through different categories, like seeds to soil, soil to fertilizer, and so on.  These maps use intervals to describe the conversion process.\n\nFirst, we'll read the input.\n\n::: {.cell}\n\n```{.python .cell-code}\nwith open('input.txt', \"r\") as f:\n    text = f.read()\n```\n:::\n\n\n## Part 1 <small class=\"text-body-secondary\">Marvelous Maps</small>\n\n::::: {.p-0 style=\"min-width: fit-content;\"}\n\n\n```{=html}\n<div class=\"card border-secondary mb-3 mx-auto\">\n  <div class=\"card-body p-3 m-1 pb-0 mb-0\">\n    <h4 class=\"card-title mt-0\">Task 1</h4>\n```\n\n\nA series of <b class='fw-bold' style='color: #3F3F3F;'>mappings</b> describe how values transition from `Seed` to `Soil` to `Fertaliser` to ... to `Location`. Find the <b class='fw-bold' style='color: #91672C;'>minimum location</b> possible from a list of <b class='fw-bold' style='color: #2F7E4A;'>seed values</b>.\n\n<h6 class=\"card-subtitle text-muted\">Example</h6>\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Figure Source\"}\nlibrary(tidyverse)\n\n#| fig-width: 5\n#| fig-height: 4\ntext <- \"seeds: 79 14 55 13\n\nseed-to-soil map:\n50 98 2\n52 50 48\n\nsoil-to-fertilizer map:\n0 15 37\n37 52 2\n39 0 15\n\nfertilizer-to-water map:\n49 53 8\n0 11 42\n42 0 7\n57 7 4\n\nwater-to-light map:\n88 18 7\n18 25 70\n\nlight-to-temperature map:\n45 77 23\n81 45 19\n68 64 13\n\ntemperature-to-humidity map:\n0 69 1\n1 0 69\n\nhumidity-to-location map:\n60 56 37\n56 93 4\"\n\nlines <- str_split_1(text, \"\\n\\n\")\n\nseeds <-\n  lines[[1]] |>\n  str_extract_all(\"\\\\d+\", simplify = TRUE) |>\n  as.numeric()\n\nsteps <-\n  lines[-1] |>\n  map(read_lines) |>\n  map(\\(.) {\n    .[-1] |>\n      str_extract_all(\"\\\\d+\", simplify = TRUE) |>\n      as_tibble() |>\n      set_names(c(\"dest_start\", \"source_start\", \"range_len\")) |>\n      mutate(across(everything(), as.numeric))\n  })\n\nget_path <- function(seed) {\n  value <- seed\n  step <- 1\n  path <- list()\n  \n  while (step <= length(steps)) {\n    dest <-\n      steps[[step]] |>\n      mutate(\n        is_valid = value >= source_start & value < source_start + range_len,\n        dest = dest_start + value - source_start\n      ) |>\n      filter(value >= source_start & value < source_start + range_len) |>\n      pull(dest)\n    \n    new_value <- c(dest, value)[1]\n    path <- bind_rows(\n      path,\n      tibble(\n        x = value,\n        xend = new_value,\n        y = 9 - step,\n        yend = y - 1\n      )\n    )\n    value = new_value\n    step <- step + 1\n  }\n  path\n}\n\nplot_seeds <- function(seeds) {\n  paths <-\n  seeds |>\n  map(get_path) |>\n  list_rbind()\n\n  plot_df <-\n    steps |>\n    list_rbind(names_to = \"step\") |>\n    mutate(\n      y = 9 - step,\n      yend = y - 1,\n      x = map2(source_start, range_len, \\(start, range) start + seq_len(range) - 1),\n      xend = map2(dest_start, range_len, \\(start, range) start + seq_len(range) - 1)\n    ) |>\n    unnest()\n  \n  points <-\n    bind_rows(\n      paths |> select(x, y),\n      paths |> select(x = xend, y = yend)\n    ) |>\n    mutate(\n      col = case_when(\n        y == 8 ~ \"#2F7E4A\",\n        y == 1 & x == min(ifelse(y == 1, x, NA), na.rm = TRUE) ~ \"#91672C\",\n        TRUE ~ \"#1577A0\"\n      ),\n      size = ifelse(col == \"#1577A0\", 1.1, 3)\n    )\n  \n  ggplot(plot_df, aes(x, y, xend = xend, yend = yend)) +\n    geom_segment(alpha = 0.5, col = \"#969696\") +\n    geom_segment(data = paths, col = \"#1577A0\") +\n    geom_point(\n      data = points,\n      mapping = aes(x, y, col = I(col), size = I(size), xend = NULL, yend = NULL)\n    ) +\n    scale_y_continuous(\n      breaks = seq_len(8),\n      labels = rev(c(\"Seed\", \"Soil\", \"Fertilizer\", \"Water\", \"Light\", \"Temperature\", \"Humidity\", \"Location\"))\n    ) +\n    theme_void() +\n    theme(\n      axis.text.y = element_text(\n        family = \"LM Roman 10\",\n        margin = margin(r = 0.8 * 11 / 2),\n        hjust = 1\n      )\n    )\n}\n\n\nplot_seeds(seeds)\n```\n\n::: {.cell-output-display}\n![](2023-05_files/figure-html/unnamed-chunk-3-1.svg){width=1512}\n:::\n:::\n\n```{=html}\n  </div>\n</div>\n```\n\n\n:::::\n\n<div style=\"clear: both;\"></div> \n\nPart 1 is straightforward. Iterate through each initial seed. For each seed, go through all the conversion maps (soil, fertilizer, etc.). If the seed value falls within a defined range in a map, we convert it to the corresponding value in the destination category (e.g., soil) based on the formula `dest_start + (seed - source_start)`. If the seed value doesn't fall within any range in a map, it remains unchanged.\n\nAfter processing all the maps for a seed, we add its final converted value (which corresponds to the location category in the last map) to a list. Finally, we find the minimum value in the locations list.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport re\n\n\nseeds, *maps_list = text.split('\\n\\n')\nseeds = [int(x) for x in re.findall(r'\\d+', seeds)]\nmaps_list = [[[int(x) for x in re.findall(r'\\d+', line)] for line in maps.splitlines()[1:]] for maps in maps_list]\n\nlocations = []\nfor seed in seeds:\n    for maps in maps_list:\n        for dest_start, source_start, range_len in maps:\n            if source_start <= seed < source_start + range_len:\n                seed = dest_start + (seed - source_start)\n                break\n    locations.append(seed)\n\nanswer1 = min(locations)\nprint(answer1)\n#> 993500720\n```\n:::\n\n```{=html}\n<div class=\"card border-info mb-3 mx-auto\">\n  <div class=\"card-header text-white bg-info\">Key Points</div>\n  <div class=\"card-body p-1\">\n    <p class=\"card-text\">\n```\n\n\n* Map each of the seeds from `Soil` to `Fertaliser` to ... to `Location`\n* At each step find the range which overlaps with the current value and use it to map to the next step\n* If no range matches then the value moves unchanged to the next step\n* Get the smallest `Location`\n\n\n```{=html}\n    </p>\n  </div>\n</div>\n```\n\n\n\n## Part 2 <small class=\"text-body-secondary\">Intersecting Intervals</small>\n\n::::: {.p-0 style=\"min-width: fit-content;\"}\n\n:::: {.pe-4}\n\n```{=html}\n<div class=\"card border-secondary mb-3 mx-auto\">\n  <div class=\"card-body p-3 m-1 pb-0 mb-0\">\n    <h4 class=\"card-title mt-0\">Task 2</h4>\n```\n\n\nGiven <b>ranges</b> of <b class='fw-bold' style='color: #2F7E4A;'>seed values</b> find the <b class='fw-bold' style='color: #91672C;'>minimum location</b> possible.\n\n\n<h6 class=\"card-subtitle text-muted\">Example</h6>\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Figure Source\"}\nseeds |>\n  split(ceiling(seq_along(seeds) / 2)) |>\n  map(\\(l) seq(l[1], l[1] + l[2])) |>\n  unlist() |>\n  plot_seeds()\n```\n\n::: {.cell-output-display}\n![](2023-05_files/figure-html/unnamed-chunk-5-1.svg){width=1512}\n:::\n:::\n\n```{=html}\n  </div>\n</div>\n```\n\n::::\n:::::\n\n\n<div style=\"clear: both;\"></div> \n\nAt first, this seems simple. Just update the list of seeds to contain all the seeds in the ranges. Unfortunately, there are billions of seeds so that would take several minutes.\n\nInstead of processing each individual seed within the initial ranges, we work directly with the ranges themselves. As we map these ranges through the conversion steps, we need to identify how they overlap with the ranges defined in each map. In some cases, this might involve splitting the initial range into smaller pieces\n\nOverlap detection and splitting will be simpler if we don't have any gaps. So let's fill in all the holes for all the maps.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_missing_ranges(maps):\n    maps.sort(key=lambda e: e[1])\n    first_val = maps[0][1]\n    if first_val != 0:\n        maps.insert(0, [0, 0, first_val])\n    \n    last_val = maps[-1][1] + maps[-1][2]\n    maps.append([last_val, last_val, 10_000_000_000])\n\n    for i in range(len(maps) - 1):\n        end = maps[i][1] + maps[i][2]\n        start = maps[i+1][1]\n        if end != start:\n            maps.append((end, end, start - end))\n\n    maps.sort(key=lambda e: e[1])\n\nfor maps in maps_list:\n    insert_missing_ranges(maps)\n```\n:::\n\n\nNow, map each of the ranges through all of the steps. If a range overlaps with a mapping range, map the overlapping portion and continue checkking the unmapped portion if there is any left.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef get_smallest_range(i, in_start, in_range_len):\n    if i == len(maps_list):\n        return in_start\n\n    output_ranges = [] # (out_start, out_range_len) pairs\n    for dest_start, source_start, range_len in maps_list[i]:\n        # No overlap\n        if source_start + range_len <= in_start or source_start >= in_start + in_range_len:\n            continue\n        \n        # Assume overlap\n        if source_start == in_start: # Source starts at input start\n            overlap_start = in_start\n            overlap_range_len = min(range_len, in_range_len)\n        elif source_start < in_start: # Source starts to left\n            overlap_start = in_start\n            overlap_end = min(source_start + range_len, in_start + in_range_len)\n            overlap_range_len = overlap_end - in_start\n        else: # Source starts to right of input start\n            overlap_start = source_start\n            overlap_end = min(source_start + range_len, in_start + in_range_len)\n            overlap_range_len = overlap_end - source_start\n\n        overlap_start = overlap_start - source_start +  dest_start\n        output_ranges.append((overlap_start, overlap_range_len))\n\n    outputs = [get_smallest_range(i + 1, out_start, out_range_len) for out_start, out_range_len in output_ranges]\n    return min(outputs) if outputs else float('inf')\n\nstarting_ranges = [seeds[i:i+2] for i in range(0, len(seeds), 2)]\nanswer2 = min(get_smallest_range(0, in_start, in_range_len) for in_start, in_range_len in starting_ranges)\nprint(answer2)\n#> 4917124\n```\n:::\n\n```{=html}\n<div class=\"card border-info mb-3 mx-auto\">\n  <div class=\"card-header text-white bg-info\">Key Points</div>\n  <div class=\"card-body p-1\">\n    <p class=\"card-text\">\n```\n\n\n* Don't iterate over all possible seeds as that would take minutes\n* Instead, maintain contiguous ranges at each step\n* `get_smallest_range` will find the smallest location accessible in the `i`th step for the given range at that step\n* If the current range overlaps with a mapping range, map the overlapping portion and check the portion that doesn't overlap\n* `insert_missing_ranges` ensures that the range `0` to `10 billion` is fully covered by filling in missing ranges\n* Guaranteeing no holes makes the overlap detection and splitting simpler\n\n\n```{=html}\n    </p>\n  </div>\n</div>\n```\n::: {.cell}\n\n:::\n\n```{=html}\n<!-- Buttons -->\n<div class=\"d-grid gap-2 d-md-flex justify-content-md-end\">\n\n  <!-- Problem Button -->\n  <a type=\"button\" class=\"btn btn-secondary\" href=\"{{< meta problem_url >}}\" role=\"button\">\n    <i class=\"bi bi-box-arrow-up-right\"></i> Problem\n  </a>\n\n  <!-- Input Button -->\n  <button type=\"button\" class=\"btn btn-secondary\" data-bs-toggle=\"modal\" data-bs-target=\"#inputModal\">\n    <i class=\"bi bi-file-earmark-text\"></i> Input\n  </button>\n\n  <!-- Solution Modal Button -->\n  <button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#solutionModal\">\n    <i class=\"bi bi-code-slash\"></i> Full Solution\n  </button>\n\n</div>\n\n\n<!-- Input Modal -->\n<div class=\"modal fade\" id=\"inputModal\" tabindex=\"-1\" aria-labelledby=\"inputModalLabel\" aria-hidden=\"true\">\n<div class=\"modal-dialog modal-dialog-scrollable modal-xl\">\n<div class=\"modal-content\">\n<div class=\"modal-header\">\n  <h5 class=\"modal-title\" id=\"inputModalLabel\">{{< meta title >}} Input</h5>\n  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n</div>\n<div class=\"modal-body\">\n```\n::: {.cell file='input.txt'}\n\n```{.r .cell-code}\nseeds: 304740406 53203352 1080760686 52608146 1670978447 367043978 1445830299 58442414 4012995194 104364808 4123691336 167638723 2284615844 178205532 3164519436 564398605 90744016 147784453 577905361 122056749\n\nseed-to-soil map:\n0 699677807 922644641\n4174180469 3833727510 120786827\n1525682201 2566557266 229511566\n3280624601 3954514337 340452959\n2228029508 2796068832 310221139\n3621077560 3280624601 553102909\n2120836342 592484641 107193166\n1982514669 227320902 138321673\n1755193767 0 227320902\n922644641 1622322448 603037560\n2538250647 365642575 226842066\n2765092713 2225360008 341197258\n\nsoil-to-fertilizer map:\n1916776044 145070025 3464138\n1920240182 0 145070025\n706160141 2208005933 115191764\n2898492924 830275742 87027483\n3489083348 3344594558 103871907\n2985520407 148534163 415139950\n821351905 917303225 327392865\n1148744770 1517236949 182706102\n295069722 3448466465 411090419\n1816984891 3244803405 99791153\n4282585972 4292886644 2080652\n3592955255 563674113 266601629\n4266462972 4158154511 16123000\n1331450872 1244696090 272540859\n2715943131 3062253612 182549793\n4284666624 4174277511 10300672\n4158154511 4184578183 108308461\n1603991731 1995012773 212993160\n2065310207 2411620688 650632924\n0 1699943051 295069722\n3400660357 2323197697 88422991\n\nfertilizer-to-water map:\n3585244197 3493316345 482900943\n2871272496 878061687 456215665\n3477664135 4187387234 107580062\n845559238 15587711 56716031\n121711204 2918313406 409174755\n1639718746 0 15587711\n530885959 2603640127 314673279\n902275269 2435903232 167736895\n2635221133 72303742 236051363\n1070012164 308355105 569706582\n1699846244 1334277352 935374889\n4279315086 3477664135 15652210\n1655306457 2269652241 44539787\n109056711 2423248739 12654493\n0 2314192028 109056711\n4068145140 3976217288 211169946\n\nwater-to-light map:\n3841742547 3016842841 17384315\n2875021919 2637593760 185450069\n3413635232 3588265685 87508205\n1311241677 236307150 54007684\n3349161906 4276682782 18284514\n896790030 1355845673 34430118\n3060471988 3835573209 145836645\n2741184131 3675773890 133837788\n1387754847 947687177 15489861\n3785944618 2057196631 55797929\n2006585491 2931426646 85416195\n3873217816 3809611678 25961531\n1667765627 643929130 34884144\n2092001686 2434956599 202637161\n1001898651 158618769 77688381\n3899179347 2253048950 181907649\n1786416461 377140410 101956748\n0 833901414 113785763\n1403244708 479097158 56815029\n3859126862 3034227156 14090954\n747996464 678813274 31450438\n869173795 963177038 27616235\n3268502638 2006585491 50611140\n113785763 0 148879571\n262665334 1511505797 386606610\n1187603975 710263712 123637702\n3319113778 3987361499 30048128\n3367446420 2885237834 46188812\n931220148 990793273 15913032\n1460059737 1006706305 120880314\n1079587032 535912187 108016943\n3645890228 2112994560 140054390\n3206308633 2823043829 62194005\n1888373209 148879571 9739198\n3501143437 3443518894 144746791\n779446902 1127586619 89726893\n947133180 1217313512 54765471\n2481910976 4017409627 259273155\n1365249361 1390275791 22505486\n4087038641 3048318110 207928655\n1702649771 1272078983 83766690\n649271944 1412781277 98724520\n2294638847 3256246765 187272129\n4081086996 3981409854 5951645\n1580940051 290314834 86825576\n\nlight-to-temperature map:\n2659452899 3773423191 23529065\n1010417677 1830019321 229964714\n1506263997 1764304095 65715226\n3017023682 3993999178 103632805\n3758361154 3931294907 62704271\n2513441862 2529586713 106552791\n3821065425 3163657189 7959671\n3410504451 3191697730 271334719\n2500616406 3150831733 12825456\n2065874786 2636139504 257698620\n4142272690 2382216135 108163002\n1377732678 1378901025 61208694\n91217027 248578952 8927711\n2463617376 3879075083 36999030\n3982807123 2315058258 67157877\n2323573406 2065874786 97274446\n958870382 916323074 51547295\n3868386197 3579887474 114420926\n931392999 1351423642 27477383\n2942753127 3694308400 74270555\n1812734437 168620508 79958444\n3301364949 2163149232 3197696\n2420847852 2166346928 42769524\n3829025096 3111470632 39361101\n2619994653 2490379137 39207576\n1571979223 1523548881 240755214\n2927532333 3916074113 15220794\n3125500723 4097631983 175864226\n1438941372 10080856 67322625\n2049903179 0 10080856\n3304562645 2209116452 105941806\n1976132043 1277652506 73771136\n2659202229 3171616860 250670\n4256036535 3463032449 38930761\n1240382391 257506663 137350287\n0 77403481 91217027\n3120656487 3768578955 4844236\n100144738 967870369 309782137\n409926875 394856950 521466124\n2682981964 4273496209 21471087\n2704453051 3501963210 77924264\n2802207515 2893838124 125324818\n3681839170 3796952256 76521984\n4250435692 3873474240 5600843\n1892692881 1440109719 83439162\n4049965000 3019162942 92307690\n2782377315 3171867530 19830200\n\ntemperature-to-humidity map:\n1281293605 2434144353 57731817\n3534843655 3623804479 36539813\n1516028925 367078655 499627624\n3340374639 3427302148 25514722\n1176213912 2491876170 105079693\n3872645852 3827818849 188531931\n508302359 1375008638 300832898\n0 866706279 508302359\n4146417618 3475254801 148549678\n4083438506 3660344292 62979112\n3365889361 3745584127 82234722\n4061177783 3723323404 22260723\n2015656549 1675841536 348405327\n1056134836 246999579 120079076\n3448124083 3452816870 22437931\n3321587434 3408514943 18787205\n3470562014 4016350780 64281641\n3571383468 3321587434 86927509\n1339025422 2024246863 177003503\n809135257 0 246999579\n2364061876 2596955863 115651453\n3658310977 4080632421 214334875\n2479713329 2201250366 232893987\n\nhumidity-to-location map:\n2408792839 708984436 12070437\n3916327360 4103567762 90492800\n2136669394 2902458135 226099404\n1414655297 721054873 722014097\n2462136308 3514619416 2467233\n1254861475 3327498132 98562162\n2362768798 569836962 46024041\n4185175199 3916327360 8885363\n421054090 234463197 201173738\n2497827912 1550759989 35404865\n849065671 0 224309687\n37059832 615861003 93123433\n4006820160 3925212723 178355039\n2863253575 1705311678 653833074\n622227828 1443068970 107691019\n2464603541 2869233764 33224371\n1353423637 3128557539 61231660\n1073375358 3426060294 47286090\n2725544642 3189789199 137708933\n26906322 224309687 10153510\n2420863276 3473346384 41273032\n729918847 1586164854 119146824\n2533232777 2676921899 192311865\n0 2359144752 26906322\n1120661448 435636935 134200027\n130183265 2386051074 290870825\n```\n:::\n\n```{=html}\n</div>\n<div class=\"modal-footer\">\n</div>\n</div>\n</div>\n</div>\n\n\n<!-- Solution Modal -->\n<div class=\"modal fade\" id=\"solutionModal\" tabindex=\"-1\" aria-labelledby=\"solutionModalLabel\" aria-hidden=\"true\">\n<div class=\"modal-dialog modal-dialog-scrollable modal-xl\">\n<div class=\"modal-content\">\n<div class=\"modal-header\">\n  <h5 class=\"modal-title\" id=\"solutionModalLabel\">{{< meta title >}} Full Solution</h5>\n  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n</div>\n<div class=\"modal-body\">\n```\n::: {.cell file='solution.py'}\n\n```{.r .cell-code}\nimport re\n\n\nwith open('input.txt', \"r\") as f:\n    text = f.read()\n\n\nseeds, *maps_list = text.split('\\n\\n')\nseeds = [int(x) for x in re.findall(r'\\d+', seeds)]\nmaps_list = [[[int(x) for x in re.findall(r'\\d+', line)] for line in maps.splitlines()[1:]] for maps in maps_list]\n\nlocations = []\nfor seed in seeds:\n    for maps in maps_list:\n        for dest_start, source_start, range_len in maps:\n            if source_start <= seed < source_start + range_len:\n                seed = dest_start + (seed - source_start)\n                break\n    locations.append(seed)\n\nanswer1 = min(locations)\nprint(answer1)\n\n\n# Part 2\ndef insert_missing_ranges(maps):\n    maps.sort(key=lambda e: e[1])\n    first_val = maps[0][1]\n    if first_val != 0:\n        maps.insert(0, [0, 0, first_val])\n    \n    last_val = maps[-1][1] + maps[-1][2]\n    maps.append([last_val, last_val, 10_000_000_000])\n\n    for i in range(len(maps) - 1):\n        end = maps[i][1] + maps[i][2]\n        start = maps[i+1][1]\n        if end != start:\n            maps.append((end, end, start - end))\n\n    maps.sort(key=lambda e: e[1])\n\n\ndef get_smallest_range(i, in_start, in_range_len):\n    if i == len(maps_list):\n        return in_start\n\n    output_ranges = [] # (out_start, out_range_len) pairs\n    for dest_start, source_start, range_len in maps_list[i]:\n        # No overlap\n        if source_start + range_len <= in_start or source_start >= in_start + in_range_len:\n            continue\n        \n        # Assume overlap\n        if source_start == in_start: # Source starts at input start\n            overlap_start = in_start\n            overlap_range_len = min(range_len, in_range_len)\n        elif source_start < in_start: # Source starts to left\n            overlap_start = in_start\n            overlap_end = min(source_start + range_len, in_start + in_range_len)\n            overlap_range_len = overlap_end - in_start\n        else: # Source starts to right of input start\n            overlap_start = source_start\n            overlap_end = min(source_start + range_len, in_start + in_range_len)\n            overlap_range_len = overlap_end - source_start\n\n        overlap_start = overlap_start - source_start +  dest_start\n        output_ranges.append((overlap_start, overlap_range_len))\n\n    outputs = [get_smallest_range(i + 1, out_start, out_range_len) for out_start, out_range_len in output_ranges]\n    return min(outputs) if outputs else float('inf')\n\n\nfor maps in maps_list:\n    insert_missing_ranges(maps)\n\nstarting_ranges = [seeds[i:i+2] for i in range(0, len(seeds), 2)]\nanswer2 = min(get_smallest_range(0, in_start, in_range_len) for in_start, in_range_len in starting_ranges)\nprint(answer2)\n```\n:::\n\n```{=html}\n</div>\n<div class=\"modal-footer\">\n<small><i>Execution took 0.01 seconds</i></small>\n</div>\n</div>\n</div>\n</div>\n```\n\n",
    "supporting": [
      "2023-05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}