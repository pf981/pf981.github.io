{
  "hash": "24d70e2d9b378cb89e4aa55aaed9ba2d",
  "result": {
    "markdown": "---\ntitle: \"2023 Day 3\"\nsubtitle: \"Gear Ratios\"\ndate: 2024-01-04\ncategories: [python, medium]\ndraft: false\nknitr:\n  opts_chunk: \n    comment: \"#>\"\n    collapse: true\nproblem_url: \"https://adventofcode.com/2023/day/3\"\ndescription: \"Medium difficulty grid puzzle involving parsing numbers, getting adjacencies, and handling duplicates.\"\n---\n\n::: {.cell}\n\n:::\n\n\n\nHo ho ho, fellow adventurers!\n\nGear up for a grid-based challenge. In [Advent of Code day 3]({{< meta problem_url >}}), we are tasked with deciphering engine schematics to fix a gondola lift.\n\nThis puzzle is trickier than the previous ones, but still manageable. It's our first grid question and involves parsing numbers, getting adjacencies, and handling duplicates.\n\nFirst, we'll read the input. Note that we use `f.read().splitlines()` instead of `f.readlines()` so our lines don't include `\\n`.\n\n::: {.cell}\n\n```{.python .cell-code}\nwith open('input.txt', \"r\") as f:\n    lines = f.read().splitlines()\n```\n:::\n\n\n## Part 1 <small class=\"text-body-secondary\">Neighbourly Numbers</small>\n\n::::: {.p-0 style=\"min-width: fit-content;\"}\n\n\n```{=html}\n<div class=\"card border-secondary mb-3 mx-auto\" style=\"max-width: 28rem;\">\n  <div class=\"card-body p-3 m-1 pb-0 mb-0\">\n    <h4 class=\"card-title mt-0\">Task 1</h4>\n```\n\n\nGet the <b class='fw-bold' style='color: #91672C;'>sum</b> of <b class='fw-bold' style='color: #2F7E4A;'>numbers</b> <b class='fw-bold' style='color: #1577A0;'>neighbouring</b> a <b class='fw-bold' style='color: #BE4844;'>symbol</b>.\n\n<h6 class=\"card-subtitle text-muted\">Example</h6>\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Figure Source\"}\nlibrary(tidyverse)\n\ndf <-\n  read_lines(\"467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\"\n) |>\n  str_split(\"\") |>\n  map(enframe, name = \"col\") |>\n  list_rbind(names_to = \"row\") |>\n  mutate(\n    color = case_when(\n      value %in% c(\"*\", \"#\", \"+\", \"$\") ~ \"#BE4844\",\n      row == 1 & col > 5 ~ \"#969696\",\n      row == 6 ~ \"#969696\",\n      !is.na(as.numeric(value)) ~ \"#2F7E4A\",\n      .default = \"#969696\"\n    ),\n    fontface = case_when(\n      color != \"#969696\" ~ \"bold\",\n      .default = \"plain\"\n    )\n  )\n\nadd <- function(row, label, plus = TRUE, is_result = FALSE) {\n  component <- annotate(\n    geom = \"text\",\n    x = 15,\n    y = row,\n    size = 7,\n    hjust = \"right\",\n    vjust = \"middle\",\n    color = ifelse(is_result, \"#91672C\", \"#969696\"),\n    fontface = ifelse(is_result, \"bold\", \"plain\"),\n    label = label,\n    family = \"LM Roman 10\"\n  )\n  if (plus) {\n    component <- list(\n      component, \n      annotate(\n        geom = \"text\",\n        x = 15,\n        y = row + 0.5,\n        size = 6,\n        hjust = \"left\",\n        vjust = \"middle\",\n        color = \"#969696\",\n        label = \"+\",\n        family = \"LM Roman 10\"\n      )\n    )\n  }\n  component\n}\n\nneighbors <- function(row, col, highlight = character()) {\n  draw_arrow <- function(direction) {\n    dr <- 0.55 * (str_detect(direction, \"S\") - str_detect(direction, \"N\"))\n    dc <- 0.55 * (str_detect(direction, \"E\") - str_detect(direction, \"W\"))\n    if (dr != 0 && dc != 0) {\n      dr <- dr * 0.8\n      dc <- dc * 0.8\n    }\n    annotate(\n      geom = \"segment\",\n      x = col + dc,\n      xend = col + (dc * 1.00001),\n      y = row + dr,\n      yend = row + (dr * 1.00001),\n      #size = 1,\n      color = ifelse(direction %in% highlight, \"#1577A0\", \"#C2C2C2\"),\n      arrow = arrow(length = unit(0.015, \"npc\"), type = \"closed\")\n    )\n  }\n  map(c(\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\"), draw_arrow)\n}\n\ndf |>\n  ggplot(aes(col, row, label = value, fontface = fontface, col = I(color))) +\n  geom_text(size = 7, family = \"LM Roman 10\") +\n  scale_y_reverse(\n    limits = c(12, 0),\n    expand = c(0, 0)\n  ) +\n  add(1, \"467\") +\n  add(3, \"35 + 633\") +\n  add(5, \"617\") +\n  add(7, \"592\") +\n  add(8, \"755\") +\n  add(10, \"664 + 598\", plus = FALSE) +\n  add(11, \"4361\", plus = FALSE, is_result = TRUE) +\n  neighbors(2, 4, c(\"S\", \"SW\", \"NW\")) +\n  neighbors(4, 7, c(\"N\", \"NE\")) +\n  neighbors(5, 4, c(\"W\")) +\n  neighbors(6, 6, c(\"SW\")) +\n  neighbors(9, 4, c(\"S\", \"SW\")) +\n  neighbors(9, 6, c(\"NE\", \"SE\", \"S\")) +\n  annotate(\n    geom = \"segment\",\n    x = 11.5,\n    xend = 15,\n    y = 10.5,\n    yend = 10.5,\n    color = \"#969696\"\n  ) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](2023-03_files/figure-html/unnamed-chunk-3-1.svg){width=396}\n:::\n:::\n\n```{=html}\n  </div>\n</div>\n```\n\n\n\n\n:::::\n\n<div style=\"clear: both;\"></div> \n\nIn part 1 we need to locate all the symbols and neighbouring numbers. Our approach is essentially this.\n\n::: {.cell}\n\n```{.python .cell-code}\nfor each symbol:\n  get the 8 neighbouring numbers\n  remove duplicates\n  add the numbers to the answer\n```\n:::\n\n\nRemoving duplicates is important. Consider the `#` symbol in the example. It is touching `633` to the north *and* touching it again to the north-east. We need to be mindful to not **double-count**.\n\nAlso, we want to be mindful to not accidentally **under-count**. Consider `..123*123..` where `*` has two *distinct* neighbours, `123` and `123`. We want to only discard true duplicates.\n\n### Digital Fingerprints\nWe'll construct a dictionary, `numbers`, which maps every digit's coordinate to its representation.\n```python\nnumbers = {\n  (0, 0): <467>,\n  (0, 1): <467>,\n  (0, 2): <467>,\n  (0, 5): <114>,\n  (0, 6): <114>,\n  (0, 7): <114>,\n  ...\n}\n```\n\nWhat should the values of this dictionary be? It can't just be the integer value as that wouldn't necessarily uniquely identify each number.\n\nWe're going to use `re.finditer` to get the start, end, and value of each number. We'll do something sneaky and just use the `re.Match` objects as the values of `numbers`!\n\nIn the code below, `match` is a `re.Match` object which contains the start, end, and value a number. It uniquely identifies that number as each `re.Match` object has its own object ID - even if the string is identical.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport re\n\n\nnumbers = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'\\d+', line):\n        for col in range(match.start(), match.end()):\n            numbers[(row, col)] = match\n```\n:::\n\n\n### Symbol Surroundings\nWe want another dictionary, `symbols`, which maps every symbol's coordinate to its character and neighbouring numbers.\n```python\nsymbols = {\n  (1, 3): ['*', [467, 35]],\n  (3, 6): ['#', [633]],\n  ...\n}\n```\n\nAgain, we can get the symbol locations using `re.finditer`.\n\n::: {.cell}\n\n```{.python .cell-code}\nsymbols = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'[^0-9.]', line):\n        symbols[(row, match.start())] = [match.group()]\n```\n:::\n\n\nThen append the neighbours. Note that `neighbours` is constructed using `set` comprehension, so it is de-duplicated.\n\n::: {.cell}\n\n```{.python .cell-code}\nfor (row, col), l in symbols.items():\n    neighbours = {numbers[(row + dr, col + dc)] for dr in range(-1, 2) for dc in range(-1, 2) if (row + dr, col + dc) in numbers}\n    l.append([int(match.group()) for match in neighbours])\n```\n:::\n\n\n### Assumption\n\nFinally, the answer is just the sum of all the neighbours.\n\nNote that this assumes that no number is neighbouring more than one symbol. If that were the case, it would be double-counted.\n\n::: {.cell}\n\n```{.python .cell-code}\nanswer1 = sum(num for _, neighbours in symbols.values() for num in neighbours)\n```\n:::\n\n\n### Summing It Up\nNow, let's put it all together.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport re\n\n\nnumbers = {}\nsymbols = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'\\d+', line):\n        for col in range(match.start(), match. end()):\n            numbers[(row, col)] = match\n    for match in re.finditer(r'[^0-9.]', line):\n        symbols[(row, match.start())] = [match.group()]\n\nfor (row, col), l in symbols.items():\n    neighbours = {numbers[(row + dr, col + dc)] for dr in range(-1, 2) for dc in range(-1, 2) if (row + dr, col + dc) in numbers}\n    l.append([int(match.group()) for match in neighbours])\n\nanswer1 = sum(num for _, neighbours in symbols.values() for num in neighbours)\nprint(answer1)\n#> 4361\n```\n:::\n\n```{=html}\n<div class=\"card border-info mb-3 mx-auto\">\n  <div class=\"card-header text-white bg-info\">Key Points</div>\n  <div class=\"card-body p-1\">\n    <p class=\"card-text\">\n```\n\n\n* `re.finditer` locates the symbols and numbers\n* The `numbers` dictionary maps digit positions to their `re.Match` object\n* The `symbols` dictionary maps symbol positions to their character and a list of neighbouring integers\n* The answer is the sum of those integers\n* This solution assumes that a number has at most one symbol neighbour\n\n\n```{=html}\n    </p>\n  </div>\n</div>\n```\n\n\n## Part 2 <small class=\"text-body-secondary\">Asterisk Adjacencies</small>\n\n::::: {.p-0 style=\"min-width: fit-content;\"}\n\n:::: {.pe-4 .float-md-start}\n\n```{=html}\n<div class=\"card border-secondary mb-3 mx-auto\" style=\"width: 25rem;\">\n  <div class=\"card-body p-3 m-1 pb-0 mb-0\">\n    <h4 class=\"card-title mt-0\">Task 2</h4>\n```\n\n\n* Identify <b class='fw-bold' style='color: #BE4844;'>*</b>s <b class='fw-bold' style='color: #1577A0;'>neighbouring exactly two</b> <b class='fw-bold' style='color: #2F7E4A;'>numbers</b>\n* Multiply its two neighbours\n* <b class='fw-bold' style='color: #91672C;'>Sum</b> these values.\n\n<h6 class=\"card-subtitle text-muted\">Example</h6>\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Figure Source\"}\nneighbors2 <- function(row, col, highlight = character(), color = \"#1577A0\") {\n  draw_arrow <- function(direction) {\n    dr <- 0.55 * (str_detect(direction, \"S\") - str_detect(direction, \"N\"))\n    dc <- 0.55 * (str_detect(direction, \"E\") - str_detect(direction, \"W\"))\n    if (dr != 0 && dc != 0) {\n      dr <- dr * 0.8\n      dc <- dc * 0.8\n    }\n    annotate(\n      geom = \"segment\",\n      x = col + dc,\n      xend = col + (dc * 1.00001),\n      y = row + dr,\n      yend = row + (dr * 1.00001),\n      color = color,\n      arrow = arrow(length = unit(0.015, \"npc\"), type = \"closed\")\n    )\n  }\n  map(highlight, draw_arrow)\n}\n\ndf |>\n  mutate(\n    color = case_when(\n      row == 4 & col == 7 ~ \"#969696\",\n      row == 5 & col == 4 ~ \"#969696\",\n      row == 6 & col == 6 ~ \"#969696\",\n      row == 9 & col == 4 ~ \"#969696\",\n      \n      row == 3 & col > 4 ~ \"#969696\",\n      row %in% c(5, 7) ~ \"#969696\",\n      row == 10 & col <= 4 ~ \"#969696\",\n      .default = color\n    ),\n    fontface = case_when(\n      color != \"#969696\" ~ \"bold\",\n      .default = \"plain\"\n    )\n  ) |>\n  ggplot(aes(col, row, label = value, fontface = fontface, col = I(color))) +\n  geom_text(size = 7, family = \"LM Roman 10\") +\n  scale_y_reverse(\n    limits = c(12, 0),\n    expand = c(0, 0)\n  ) +\n  add(2, expression(\"467 \" %*% \" 35\")) +\n  add(9, expression(\"755 \" %*% \" 598\"), plus = FALSE) +\n  add(11, \"467835\", plus = FALSE, is_result = TRUE) +\n  neighbors2(2, 4, c(\"S\", \"NW\")) +\n  neighbors2(4, 7, c(\"N\"), \"#C2C2C2\") +\n  neighbors2(5, 4, c(\"W\"), \"#C2C2C2\") +\n  neighbors2(6, 6, c(\"SW\"), \"#C2C2C2\") +\n  neighbors2(9, 4, c(\"S\"), \"#C2C2C2\") +\n  neighbors2(9, 6, c(\"NE\", \"S\")) +\n  annotate(\n    geom = \"segment\",\n    x = 11.3,\n    xend = 15,\n    y = 10.5,\n    yend = 10.5,\n    color = \"#969696\"\n  ) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](2023-03_files/figure-html/unnamed-chunk-10-1.svg){width=396}\n:::\n:::\n\n```{=html}\n  </div>\n</div>\n```\n\n::::\n\nPart 2 tasks us with indentifying gears which are `*` symbols with exactly `2` neighbours.\n\nThis is straightforward as we have the `symbols` dictionary from part 1.\n\n:::::\n\n<div style=\"clear: both;\"></div> \n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport math\n\n\nanswer2 = sum(math.prod(nums) for symbol, nums in symbols.values() if symbol == '*' and len(nums) == 2)\nprint(answer2)\n#> 467835\n```\n:::\n\n```{=html}\n<div class=\"card border-info mb-3 mx-auto\">\n  <div class=\"card-header text-white bg-info\">Key Points</div>\n  <div class=\"card-body p-1\">\n    <p class=\"card-text\">\n```\n\n\n* Filter `symbols` where the symbol is `*` and the number of neighbours is `2`\n* Get the product of neighbours, then the sum\n\n\n```{=html}\n    </p>\n  </div>\n</div>\n```\n\n\n## Stocking Stuffers <small class=\"text-body-secondary\">Auspicious Assumptions</small>\nOur solution assumes that no number is neighbouring more than one symbol. This is true of our input.\n\nTo make the solution more general and handle cases where numbers could neighbor multiple symbols, we'd need to adjust our approach to avoid potential double-counting. However, this makes the solution clunkier.\n\n::: {.cell}\n\n```{.python .cell-code}\nimport math\nimport re\n\n\nnumbers = {}\nsymbols = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'\\d+', line):\n        for col in range(match.start(), match.end()):\n            numbers[(row, col)] = match\n    for match in re.finditer(r'[^0-9.]', line):\n        symbols[(row, match.start())] = [match.group()]\n\nfor (row, col), l in symbols.items():\n    neighbours = {numbers[(row + dr, col + dc)] for dr in range(-1, 2) for dc in range(-1, 2) if (row + dr, col + dc) in numbers}\n    l.append(neighbours)\n\npart_number_matches = set().union(*(neighbours for _, neighbours in symbols.values()))\nanswer1 = sum(int(match.group()) for match in part_number_matches)\nprint(answer1)\n#> 4361\n\nanswer2 = sum(math.prod(int(match.group()) for match in matches) for symbol, matches in symbols.values() if symbol == '*' and len(matches) == 2)\nprint(answer2)\n#> 467835\n```\n:::\n\n```{=html}\n<div class=\"card border-info mb-3 mx-auto\">\n  <div class=\"card-header text-white bg-info\">Key Points</div>\n  <div class=\"card-body p-1\">\n    <p class=\"card-text\">\n```\n\n\n* `numbers` now stores its neighbours as a `set` of `re.Match` objects and not just a `list` of `int`s\n* `set().union(*l)` will union all the `set`s in `l`\n* The matches are only converted to integers after de-duplication\n* This solution does **not** assume that a number has at most one symbol neighbour\n\n\n```{=html}\n    </p>\n  </div>\n</div>\n```\n\n\nIt's fine to tailor your solution to your input. While a general solution was possible for this problem, [some days](../20/2023-20.html) are practically impossible to solve in the general case and **require** crafting a solution specific to your input.\n\n::: {.cell}\n\n:::\n\n```{=html}\n<!-- Buttons -->\n<div class=\"d-grid gap-2 d-md-flex justify-content-md-end\">\n\n  <!-- Problem Button -->\n  <a type=\"button\" class=\"btn btn-secondary\" href=\"{{< meta problem_url >}}\" role=\"button\">\n    <i class=\"bi bi-box-arrow-up-right\"></i> Problem\n  </a>\n\n  <!-- Input Button -->\n  <button type=\"button\" class=\"btn btn-secondary\" data-bs-toggle=\"modal\" data-bs-target=\"#inputModal\">\n    <i class=\"bi bi-file-earmark-text\"></i> Input\n  </button>\n\n  <!-- Solution Modal Button -->\n  <button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#solutionModal\">\n    <i class=\"bi bi-code-slash\"></i> Full Solution\n  </button>\n\n</div>\n\n\n<!-- Input Modal -->\n<div class=\"modal fade\" id=\"inputModal\" tabindex=\"-1\" aria-labelledby=\"inputModalLabel\" aria-hidden=\"true\">\n<div class=\"modal-dialog modal-dialog-scrollable modal-xl\">\n<div class=\"modal-content\">\n<div class=\"modal-header\">\n  <h5 class=\"modal-title\" id=\"inputModalLabel\">{{< meta title >}} Input</h5>\n  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n</div>\n<div class=\"modal-body\">\n```\n::: {.cell file='input.txt'}\n\n```{.r .cell-code}\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n```\n:::\n\n```{=html}\n</div>\n<div class=\"modal-footer\">\n</div>\n</div>\n</div>\n</div>\n\n\n<!-- Solution Modal -->\n<div class=\"modal fade\" id=\"solutionModal\" tabindex=\"-1\" aria-labelledby=\"solutionModalLabel\" aria-hidden=\"true\">\n<div class=\"modal-dialog modal-dialog-scrollable modal-xl\">\n<div class=\"modal-content\">\n<div class=\"modal-header\">\n  <h5 class=\"modal-title\" id=\"solutionModalLabel\">{{< meta title >}} Full Solution</h5>\n  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n</div>\n<div class=\"modal-body\">\n```\n::: {.cell file='solution.py'}\n\n```{.r .cell-code}\nimport math\nimport re\n\n\nwith open(r'input.txt', \"r\") as f:\n    lines = f.read().splitlines()\n\n\nnumbers = {}\nsymbols = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'\\d+', line):\n        for col in range(match.start(), match. end()):\n            numbers[(row, col)] = match\n    for match in re.finditer(r'[^0-9.]', line):\n        symbols[(row, match.start())] = [match.group()]\n\nfor (row, col), l in symbols.items():\n    neighbours = {numbers[(row + dr, col + dc)] for dr in range(-1, 2) for dc in range(-1, 2) if (row + dr, col + dc) in numbers}\n    l.append([int(match.group()) for match in neighbours])\n\nanswer1 = sum(num for _, neighbours in symbols.values() for num in neighbours)\nprint(answer1)\n\n\n# Part 2\nanswer2 = sum(math.prod(nums) for symbol, nums in symbols.values() if symbol == '*' and len(nums) == 2)\nprint(answer2)\n```\n:::\n\n```{=html}\n</div>\n<div class=\"modal-footer\">\n<small><i>Execution took 0.01 seconds</i></small>\n</div>\n</div>\n</div>\n</div>\n```\n\n",
    "supporting": [
      "2023-03_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}