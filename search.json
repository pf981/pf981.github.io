[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Paul Foster’s Advent of Code Blog"
  },
  {
    "objectID": "posts/2023/06/2023-06.html",
    "href": "posts/2023/06/2023-06.html",
    "title": "2023 Day 6",
    "section": "",
    "text": "Ho ho ho, fellow adventurers!\nAdvent of Code day 6 presents a problem involving toy boat races, where participants must find optimal strategies to beat existing distance records.\nThis puzzle can be solved with some basic maths involving quadratics.\nFirst, we’ll read the input.\nwith open('input.txt', \"r\") as f:\n    lines = f.readlines()"
  },
  {
    "objectID": "posts/2023/06/2023-06.html#part-1-hold-to-gold",
    "href": "posts/2023/06/2023-06.html#part-1-hold-to-gold",
    "title": "2023 Day 6",
    "section": "Part 1 Hold to Gold",
    "text": "Part 1 Hold to Gold\n\n\n  \n    Task 1\nYou’re given a list of races for toy boats. Each race contains a race duration (ms) and a current distance record (mm).\nThe distance a toy boat travels in a race is determined by how long you hold the button at the start: each millisecond of holding increases the boat’s speed by 1 mm/ms, but also reduces the remaining time for movement. After releasing the button, the boat travels at its accumulated speed for the rest of the race duration.\nFind the number of ways to beat each race’s record and get the product of those numbers.\n\nExample\n\nThe diagram below illustrates the calculations for this example of three races.\nTime:      7  15   30\nDistance:  9  40  200\n\n\nFigure Source\nlibrary(tidyverse)\n\n\n\ntext &lt;- \"Time:      7  15   30\nDistance:  9  40  200\"\n\nlines &lt;-\n  str_split_1(text, \"\\n\") |&gt;\n  map(\\(line) str_extract_all(line, \"\\\\d+\", simplify = TRUE)) |&gt;\n  map(as.numeric)\n\ncount_ways &lt;- function(t, d) {\n  upper &lt;- (-t - sqrt(t ^ 2 - 4 * (-1) * (-d))) / 2 * (-1)\n  lower &lt;- (-t + sqrt(t ^ 2 - 4 * (-1) * (-d))) / 2 * (-1)\n  ceiling(upper) - floor(lower) - 1\n}\n\ncreate_plot &lt;- function(race_id, race_duration, record, x_limit = 30) {\n  df &lt;- tibble(wait_time = seq(from = 0, to = race_duration, by = 1)) |&gt;\n    mutate(\n      distance = wait_time * (race_duration - wait_time),\n      fill = case_when(\n        distance &gt; record ~ \"#1577A0\",\n        TRUE ~ \"#969696\"\n      )\n    )\n  \n  ggplot(df, aes(wait_time, distance, fill = I(fill))) +\n    geom_col() +\n    geom_hline(\n      aes(yintercept = record),\n      data = NULL,\n      col = \"#BE4844\",\n      linetype = \"longdash\",\n      size = 0.8\n    ) +\n    scale_x_continuous(\n      breaks = seq(from = 0, to = race_duration, by = 1),\n      labels = \\(break_value) ifelse(break_value == race_duration, glue::glue(\"&lt;b style = 'color:#2F7E4A;'&gt;{break_value}&lt;/b&gt;\"), as.character(break_value)),\n      limits = c(-0.5, x_limit),\n      expand = c(0, 0)\n    ) +\n    scale_y_continuous(\n      breaks = c(scales::breaks_pretty(n = 4)(df$distance), record),\n      labels = \\(break_value) ifelse(break_value == record, glue::glue(\"&lt;b style = 'color:#BE4844;'&gt;{break_value}&lt;/b&gt;\"), as.character(break_value)),\n      expand = c(0, 0)\n    ) +\n    labs(\n      title = glue::glue(\"Race {race_id}\"),\n      subtitle = glue::glue(\"&lt;b style = 'color:#2F7E4A;'&gt;Race Duration: {race_duration}ms&lt;/b&gt;, &lt;b style = 'color:#BE4844;'&gt;Record: {record}mm&lt;/b&gt;, &lt;b style = 'color:#1577A0;'&gt;Ways to Beat Record: {count_ways(race_duration, record)}&lt;/b&gt;\"),\n      x = \"\",\n      y = \"\"\n    ) +\n    theme_minimal(base_family = \"LM Roman 10\") +\n    theme(\n      panel.grid = element_blank(),\n      axis.line.x.bottom = element_line(color  = \"#CCCCCC\"),\n      axis.ticks.x.bottom = element_line(color  = \"#CCCCCC\"),\n      axis.line.y.left = element_line(color  = \"#CCCCCC\"),\n      axis.ticks.y.left = element_line(color  = \"#CCCCCC\"),\n      axis.text.x = ggtext::element_markdown(),\n      axis.text.y = ggtext::element_markdown(),\n      plot.subtitle = ggtext::element_markdown()\n    )\n}\n\nplots &lt;-\n  pmap(list(seq_along(lines[[1]]), lines[[1]], lines[[2]]), create_plot) |&gt;\n  modify_at(2, \\(p) p + labs(y = \"Distance (mm)\")) |&gt;\n  modify_at(3, \\(p) p + labs(x = \"Button Hold Time (ms)\"))\n\n# Using cowplot or egg with custom font and markdown made the subtitle spacing incorrect\n# Works fine with gridExtra::grid.arrange but the axes aren't aligned\n# cowplot::plot_grid(plotlist = plots, ncol = 1)\n# gridExtra::grid.arrange(plots[[1]], plots[[2]], plots[[3]], ncol = 1)\n# egg::ggarrange(plots[[1]], plots[[2]], plots[[3]], ncol = 1)\n\n# This was the best way to get the font rendering correctly and the axes aligned\nplots |&gt;\n  map(ggplotGrob) %&gt;%\n  do.call(gridExtra::gtable_rbind, .) |&gt;\n  grid::grid.draw()\n\n\n\n\n\n\n\\[\n\\newcommand{\\blue}[1]{\\color{##1577A0}\\textbf{#1}\\color{##55595C}}\n\\newcommand{\\orange}[1]{\\color{##91672C}\\textbf{#1}\\color{##55595C}}\n\\newcommand{\\red}[1]{\\color{##BE4844}\\textbf{#1}\\color{##55595C}}\n\\newcommand{\\green}[1]{\\color{##2F7E4A}\\textbf{#1}\\color{##55595C}}\n\\]\n\n\\[\\blue{4} * \\blue{8} * \\blue{9} = \\orange{288}\\]\n  \n\n\n\n\n\n\nParabolic Pondering\nTo calculate the number of ways to beat the record, we can find the difference between the upper and lower \\(x\\) values of the blue bars.\nThese bounds can be found as the intersection of the red line and a frowny parabola which is a function of the button hold time and race duration.\n\n\nAlgebraic Adventures\nGiven:\n\n\\(\\green{T}\\): Total race time in milliseconds.\n\\(\\red{D}\\): Record distance that needs to be beaten, in millimeters.\n\\(w\\): Time in milliseconds for which the button is held down at the start of the race.\n\nThe distance your boat travels when the button is held for \\(w\\) milliseconds with total race time \\(T\\) is: \\[w \\cdot (T - w)\\]\nThis matches the current record \\(D\\), when: \\[D = w \\cdot (T - w)\\]\nThis can be rewritten as a quadratic equation in terms of \\(w\\): \\[0 = -w^2 + T \\cdot w - D\\]\nTo solve for \\(w\\), we use the quadratic formula: \\[w = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\\]\nIn our equation, \\(a = -1\\), \\(b = T\\), and \\(c = -D\\). Thus, substituting these values into the quadratic formula yields: \\[w = \\frac{-T \\pm \\sqrt{T^2 - 4 \\cdot (-1) \\cdot (-D)}}{2 \\cdot (-1)}\\]\nSimplifying, we get two values for (w), which represent the upper and lower bounds of the button holding time that allows the boat to exceed the record distance: \\[\n\\begin{aligned}\nw_{upper} &= \\frac{-T - \\sqrt{T^2 - 4D}}{2 \\cdot (-1)} \\\\\nw_{lower} &= \\frac{-T + \\sqrt{T^2 - 4D}}{2 \\cdot (-1)} \\\\\n\\end{aligned}\n\\]\nTo find the number of ways to beat the record, we calculate the number of integers in the open interval \\((w_{lower}, w_{upper})\\): \\[\\text{\\blue{Number of ways}} = \\lceil w_{upper} \\rceil - \\lfloor w_{lower} \\rfloor - 1\\]\nThen simply plug in the numbers for each race and get the product of the resulting values.\n\nimport math\nimport re\n\n\ndef count_ways(T, D):\n    upper = (-T - math.sqrt(T ** 2 - 4 * (-1) * (-D))) / 2 * (-1)\n    lower = (-T + math.sqrt(T ** 2 - 4 * (-1) * (-D))) / 2 * (-1)\n    return math.ceil(upper) - math.floor(lower) - 1\n\n\ntimes, distances = [[int(x) for x in re.findall(r'\\d+', line)] for line in lines]\nanswer1 = math.prod(count_ways(time, distance) for time, distance in zip(times, distances))\nprint(answer1)\n#&gt; 288\n\n\n  Key Points\n  \n    \n\nFind the upper and lower button hold times which beat the record\nThis can be expressed as the intersection between \\(f(x) = D\\) and \\(f(x) = w \\cdot (T - w)\\)\nCompute the product of the differences between the upper and lower bounds"
  },
  {
    "objectID": "posts/2023/06/2023-06.html#part-2-magnitude-multiplied",
    "href": "posts/2023/06/2023-06.html#part-2-magnitude-multiplied",
    "title": "2023 Day 6",
    "section": "Part 2 Magnitude Multiplied",
    "text": "Part 2 Magnitude Multiplied\n\n\n\n  \n    Task 2\nRather than multiple races, the race durations and distance records are each concatenated to form one giant race.\nFind the number of ways to beat this race’s record.\n\nExample\n\nTime:      71530\nDistance:  940200\n\n\nFigure Source\n# https://stackoverflow.com/questions/35511951/r-ggplot2-collapse-or-remove-segment-of-y-axis-from-scatter-plot\nsquish_trans &lt;- function(from, to, factor) {\n  trans &lt;- function(x) {\n    if (any(is.na(x))) return(x)\n    isq &lt;- x &gt; from & x &lt; to\n    ito &lt;- x &gt;= to\n    \n    x[isq] &lt;- from + (x[isq] - from)/factor\n    x[ito] &lt;- from + (to - from)/factor + (x[ito] - to)\n    \n    x\n  }\n\n  inv &lt;- function(x) {\n    if (any(is.na(x))) return(x)\n\n    isq &lt;- x &gt; from & x &lt; from + (to - from)/factor\n    ito &lt;- x &gt;= from + (to - from)/factor\n\n    x[isq] &lt;- from + (x[isq] - from) * factor\n    x[ito] &lt;- to + (x[ito] - (from + (to - from)/factor))\n    \n    x\n  }\n  \n  scales::trans_new(\"squished\", trans, inv)\n}\n\ntime_distance &lt;-\n  lines |&gt;\n  map_chr(str_c, collapse = \"\") |&gt;\n  map_int(as.integer)\n\nrace_duration &lt;- time_distance[[1]]\nrecord &lt;- time_distance[[2]]\n\nlower_upper &lt;- function(t, d) {\n  upper &lt;- (-t - sqrt(t ^ 2 - 4 * (-1) * (-d))) / 2 * (-1)\n  lower &lt;- (-t + sqrt(t ^ 2 - 4 * (-1) * (-d))) / 2 * (-1)\n  c(floor(lower), ceiling(upper) - 1)\n}\n\nlower_upper_values &lt;- lower_upper(race_duration, record)\nlower_win &lt;- lower_upper_values[[1]]\nupper_win &lt;- lower_upper_values[[2]]\n\nresolution &lt;- 1000\n\ndf &lt;- tibble(\n  wait_time = unique(c(\n    seq(from = 0, to = lower_win, length.out = resolution),\n    seq(from = lower_win, to = upper_win, length.out = resolution),\n    seq(from = upper_win, to = race_duration, length.out = resolution)\n  )),\n  distance = wait_time * (race_duration - wait_time),\n  is_win = wait_time &gt; lower_win & wait_time &lt; upper_win\n)\n\nggplot(NULL, aes(wait_time, distance)) +\n  geom_area(data = filter(df, wait_time &lt;= lower_win), fill = \"#969696\") +\n  geom_area(data = filter(df, wait_time &gt;= upper_win), fill = \"#969696\") +\n  geom_area(data = filter(df, wait_time &gt; lower_win & wait_time &lt; upper_win), fill = \"#1577A0\") +\n  geom_hline(\n    aes(yintercept = record),\n    data = NULL,\n    col = \"#BE4844\",\n    linetype = \"longdash\",\n    size = 0.8\n  ) +\n  scale_x_continuous(\n    minor_breaks = seq(from = 0, to = race_duration, length.out = 100),\n    labels = \\(break_value) ifelse(break_value == race_duration, glue::glue(\"&lt;b style = 'color:#2F7E4A;'&gt;{scales::label_comma()(break_value)}&lt;/b&gt;\"), scales::label_comma()(break_value)),\n    breaks = c(0, 14, seq(from = 10000, to = 60000, by = 10000), 71516, race_duration),\n    expand = c(0, 0),\n    transform = squish_trans(lower_win , upper_win + 1, 1000)\n  ) +\n  scale_y_continuous(\n    breaks = c(0, record, 100000000, 500000000, 1000000000),\n    minor_breaks = seq(from = 0, to = 1279135224, length.out = 50),\n      labels = \\(break_value) ifelse(break_value == record, glue::glue(\"&lt;b style = 'color:#BE4844;'&gt;{scales::label_comma()(break_value)}&lt;/b&gt;\"), scales::label_comma()(break_value)),\n    transform = squish_trans(940200, 1279135224, 1000),\n    expand = c(0, 0)\n  ) +\n    labs(\n      title = \"Combined Race\",\n      subtitle = glue::glue(\"&lt;b style = 'color:#2F7E4A;'&gt;Race Duration: {scales::label_comma()(race_duration)}ms&lt;/b&gt;, &lt;b style = 'color:#BE4844;'&gt;Record: {scales::label_comma()(record)}mm&lt;/b&gt;, &lt;b style = 'color:#1577A0;'&gt;Ways to Beat Record: {scales::label_comma()(count_ways(race_duration, record))}&lt;/b&gt;\"),\n      x = \"Button Hold Time (ms)\",\n      y = \"Distance (mm)\"\n    ) +\n    theme_minimal(base_family = \"LM Roman 10\") +\n    theme(\n      axis.line.x.bottom = element_line(color  = \"#CCCCCC\"),\n      axis.ticks.x.bottom = element_line(color  = \"#CCCCCC\"),\n      axis.line.y.left = element_line(color  = \"#CCCCCC\"),\n      axis.ticks.y.left = element_line(color  = \"#CCCCCC\"),\n      axis.text.x = ggtext::element_markdown(),\n      axis.text.y = ggtext::element_markdown(),\n      plot.subtitle = ggtext::element_markdown(),\n      plot.margin = margin(t = 0, r = 40, b = 0, l = 0, unit = \"pt\")\n    )\n\n\n\n\n\nTails zoomed 1000x for readability\n\n\n\n\n  \n\n\n\n\n\n\nJust plug the new numbers into the same formula.\n\ntime, distance = [int(''.join(str(x) for x in dim)) for dim in [times, distances]]\nanswer2 = count_ways(time, distance)\nprint(answer2)\n#&gt; 71503\n\n\n  Key Points\n  \n    \n\nConcatenate the race durations and distance records\nCompute the number of ways to beat this race’s record using the same formula as part 1\n\n    \n  \n\n\n\n\n  \n  \n     Problem\n  \n\n  \n  \n     Input\n  \n\n  \n  \n     Full Solution\n  \n\n\n\n\n\n\n\n\n\n  2023 Day 6 Input\n  \n\n\n\nTime:      7  15   30\nDistance:  9  40  200\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  2023 Day 6 Full Solution\n  \n\n\n\nimport math\nimport re\n\n\nwith open('input.txt', \"r\") as f:\n    lines = f.readlines()\n\n\ndef count_ways(T, D):\n    #     D = w * (T - w)\n    # =&gt;  0 = -w**2 + T*w - D\n    # =&gt;  zeroes at (-T +- sqrt(T**2 - 4*(-1)*(-D))) / 2*(-1)  (quadratic formula)\n    upper = (-T - math.sqrt(T ** 2 - 4 * (-1) * (-D))) / 2 * (-1)\n    lower = (-T + math.sqrt(T ** 2 - 4 * (-1) * (-D))) / 2 * (-1)\n    return math.ceil(upper) - math.floor(lower) - 1\n\n\ntimes, distances = [[int(x) for x in re.findall(r'\\d+', line)] for line in lines]\nanswer1 = math.prod(count_ways(time, distance) for time, distance in zip(times, distances))\nprint(answer1)\n\n\n# Part 2\ntime, distance = [int(''.join(str(x) for x in dim)) for dim in [times, distances]]\nanswer2 = count_ways(time, distance)\nprint(answer2)\n\n\n\nExecution took 0.01 seconds"
  },
  {
    "objectID": "posts/2023/08/2023-08.html",
    "href": "posts/2023/08/2023-08.html",
    "title": "2023 Day 8",
    "section": "",
    "text": "Ho ho ho, fellow adventurers!\nAdvent of Code day 8 invites us to solve cycles\nFirst, we’ll read the input.\nwith open(\"input.txt\", \"r\") as f:\n    text = f.read()"
  },
  {
    "objectID": "posts/2023/08/2023-08.html#part-1-hand-hierarchy",
    "href": "posts/2023/08/2023-08.html#part-1-hand-hierarchy",
    "title": "2023 Day 8",
    "section": "Part 1 Hand Hierarchy",
    "text": "Part 1 Hand Hierarchy\n\n\n  \n    Task 1\nYou are given a list of 5 card hands and their corresponding bids. Rank each hand and calculate the winnings as the product of the rank and bid. Compute the total winnings.\nHands are ranked by their type. If two hands are of the same type, their ordering is then determined by comparing the strength of the individual cards, starting from the first card to the fifth, as needed.\n\nExample\n\nTODO\n  \n\n\n\n\n\n\nimport collections\nimport itertools\nimport re\n\n\ndef get_steps(pos):\n    it = itertools.cycle(instructions)\n    steps = 0\n    while pos[-1] != \"Z\":\n        pos = m[pos][next(it) == \"R\"]\n        steps += 1\n\n    return steps\n\n\ninstructions, m = text.split(\"\\n\\n\")\nm = {\n    pos: (left, right)\n    for pos, left, right in [\n        re.findall(r\"[A-Z0-9]{3}\", line) for line in m.splitlines()\n    ]\n}\nanswer1 = get_steps(\"AAA\")\nprint(answer1)\n#&gt; 2\n\n\n  Key Points\n  \n    \n\nRanking Camel Cards hands involves two levels of ordering:\n\nPrimary ordering is based on the type of hand, determined by the pattern of card frequencies\nSecondary ordering evaluates the specific values of the cards within a hand\n\nA combined key function, hand_bid_order, uses both the primary and secondary orderings to sort the hands from weakest to strongest"
  },
  {
    "objectID": "posts/2023/08/2023-08.html#part-2-jokers-wild",
    "href": "posts/2023/08/2023-08.html#part-2-jokers-wild",
    "title": "2023 Day 8",
    "section": "Part 2 Jokers Wild",
    "text": "Part 2 Jokers Wild\n\n\n\n  \n    Task 2\nJs are now wild Jokers and act as whatever card results in the strongest type.\nDetermine the new hand ranks and compute the total winnings.\n\nExample\n\nTodo\n  \n\n\n\n\n\n\nCreate a new function, hand_bid_order_wild, which evaluates the maximum potential strength of a hand by considering all possible substitutions of J with other cards.\n\nimport math\n\n\nsteps = [get_steps(start_pos) for start_pos in m if start_pos[-1] == \"A\"]\nanswer2 = math.lcm(*steps)\nprint(answer2)\n#&gt; 2\n\n\n  Key Points\n  \n    \n\nCompute the max primary_order when replacing Js with every other card\nJokers only affect the primary_order - the secondary_order is calculated the same way\n\n    \n  \n\n\n\n\n  \n  \n     Problem\n  \n\n  \n  \n     Input\n  \n\n  \n  \n     Full Solution\n  \n\n\n\n\n\n\n\n\n\n  2023 Day 8 Input\n  \n\n\n\nRL\n\nAAA = (BBB, CCC)\nBBB = (DDD, EEE)\nCCC = (ZZZ, GGG)\nDDD = (DDD, DDD)\nEEE = (EEE, EEE)\nGGG = (GGG, GGG)\nZZZ = (ZZZ, ZZZ)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  2023 Day 8 Full Solution\n  \n\n\n\nimport collections\nimport itertools\nimport math\nimport re\n\n\nwith open(\"input.txt\", \"r\") as f:\n    text = f.read()\n\n\ndef get_steps(pos):\n    it = itertools.cycle(instructions)\n    steps = 0\n    while pos[-1] != \"Z\":\n        pos = m[pos][next(it) == \"R\"]\n        steps += 1\n\n    return steps\n\n\ninstructions, m = text.split(\"\\n\\n\")\nm = {\n    pos: (left, right)\n    for pos, left, right in [\n        re.findall(r\"[A-Z0-9]{3}\", line) for line in m.splitlines()\n    ]\n}\nanswer1 = get_steps(\"AAA\")\nprint(answer1)\n\n\n# Part 2\nsteps = [get_steps(start_pos) for start_pos in m if start_pos[-1] == \"A\"]\nanswer2 = math.lcm(*steps)\nprint(answer2)\n\n\n\nExecution took 0.01 seconds"
  },
  {
    "objectID": "posts/2023/02/2023-02.html",
    "href": "posts/2023/02/2023-02.html",
    "title": "2023 Day 2",
    "section": "",
    "text": "Ho ho ho, fellow adventurers!\nAdvent of Code day 2 lands us on Snow Island playing a cube game with an Elf. This is a straightforward puzzle involving basic regex and arithmetic.\nFirst, we’ll read the input.\nwith open('input.txt', \"r\") as f:\n    lines = f.readlines()"
  },
  {
    "objectID": "posts/2023/02/2023-02.html#part-1-prismatic-filters",
    "href": "posts/2023/02/2023-02.html#part-1-prismatic-filters",
    "title": "2023 Day 2",
    "section": "Part 1 Prismatic Filters",
    "text": "Part 1 Prismatic Filters\n\n\\[\n\\newcommand{\\game}[1]{\\large\\phantom{\\textbf{9}}\\normalsize\\llap{\\text{#1}}}\n\\]\n\\[\n\\newcommand{\\Game}[1]{\\color{##2F7E4A}\\large\\phantom{\\textbf{9}}\\llap{\\textbf{#1}}\\color{##55595C}\\normalsize}\n\\]\n\\[\n\\newcommand{\\grey}[1]{\\color{##969696}#1}\n\\]\n\\[\n\\newcommand{\\plus}{\\smash{\\lower{0.5pc}\\color{##969696}+}}\n\\]\n\\[\n\\newcommand{\\red}[1]{\\large\\text{\\color{##BE4844}\\textbf{#1}}\\normalsize}\n\\]\n\\[\n\\newcommand{\\green}[1]{\\large\\text{\\color{##2F7E4A}\\textbf{#1}}\\normalsize}\n\\]\n\\[\n\\newcommand{\\blue}[1]{\\large\\text{\\color{##1577A0}\\textbf{#1}}\\normalsize}\n\\]\n\n\n\n\n  \n    Task 1\n    \nGet the sum of game IDs excluding games with more than 12 red, 13 green, or 14 blue.\n\nExample\n\n\\[\n\\begin{aligned}\n&\\text{Game }\\Game{1}\\text{: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green} & \\grey{1} & \\plus\\\\\n&\\text{Game }\\Game{2}\\text{: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue} & \\grey{2} & \\plus\\\\\n&\\text{Game }\\game{3}\\text{: 8 green, 6 blue, }\\red{20 red}\\text{; 5 blue, 4 red, 13 green; 5 green, 1 red} & \\\\\n&\\text{Game }\\game{4}\\text{: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, }\\red{15 blue}\\text{, }\\red{14 red} & \\\\\n&\\text{Game }\\Game{5}\\text{: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green} & \\grey{5} \\llap{\\lower{0.4pc}\\underline{\\phantom{\\large{\\textbf{8}}}}} \\\\\n& & \\color{#91672C}\\large{\\textbf{8}}\n\\end{aligned}\n\\]\n    \n  \n\n\nIn part 1, we need to identify which games would be possible if there were only\n\n12 red cubes\n13 green cubes, and\n14 blue cubes\n\nFor example, if a line contains \"13 red\", we know we need to exclude it.\nWe’ll use regex to extract the largest red, green, and blue values. Then we’ll keep only games where\n\nlargest_red ≤ 12, and\nlargest_green ≤ 13, and\nlargest_blue ≤ 14\n\n\n\n\n\n\nimport re\n\n\ndef extract_cubes(line):\n    return [extract_max(line, color) for color in ['red', 'green', 'blue']]\n\n\ndef extract_max(line, c):\n    return max(int(num) for num in re.findall(r'(\\d+) ' + c, line))\n\n\nmax_cubes = [extract_cubes(line) for line in lines]\nanswer1 = sum(game_id for game_id, cubes in enumerate(max_cubes, 1) if cubes[0] &lt;= 12 and cubes[1] &lt;= 13 and cubes[2] &lt;= 14)\nprint(answer1)\n#&gt; 8\n\n\n  Key Points\n  \n    \n\nextract_max finds highest quantity of a single colour using regex\nextract_cubes function find highest quantity of every colour\nFilter and sum the game IDs based on the colour constraints"
  },
  {
    "objectID": "posts/2023/02/2023-02.html#part-2-combining-cube-colour-counts",
    "href": "posts/2023/02/2023-02.html#part-2-combining-cube-colour-counts",
    "title": "2023 Day 2",
    "section": "Part 2 Combining Cube Colour Counts",
    "text": "Part 2 Combining Cube Colour Counts\n\n\n\n  \n    Task 2\n    \nMultiply the largest red, green, and blue values. Then get the sum.\n\nExample\n\n\\[\n\\begin{aligned}\n&\\text{Game 1: 3 blue, }\\red{4 red}\\text{; 1 red, }\\green{2 green}\\text{, }\\blue{6 blue}\\text{; 2 green} & \\grey{4 \\times 2 \\times 6} & \\plus\\\\\n&\\text{Game 2: 1 blue, 2 green; }\\green{3 green}\\text{, }\\blue{4 blue}\\text{, }\\red{1 red}\\text{; 1 green, 1 blue} & \\grey{3 \\times 4 \\times 1} & \\plus\\\\\n&\\text{Game 3: 8 green, }\\blue{6 blue}\\text{, }\\red{20 red}\\text{; 5 blue, 4 red, }\\green{13 green}\\text{; 5 green, 1 red} & \\grey{6 \\times 20 \\times 13} & \\plus\\\\\n&\\text{Game 4: 1 green, 3 red, 6 blue; }\\green{3 green}\\text{, 6 red; 3 green, }\\blue{15 blue}\\text{, }\\red{14 red} & \\grey{3 \\times 15 \\times 14} & \\plus\\\\\n&\\text{Game 5: }\\red{6 red}\\text{, 1 blue, }\\green{3 green}\\text{; }\\blue{2 blue}\\text{, 1 red, 2 green} & \\grey{6 \\times 3 \\times 2} \\llap{\\lower{0.4pc}\\underline{\\phantom{3 \\times 15 \\times 14}}} \\\\\n& & \\color{#91672C}\\large{\\textbf{2286}}\n\\end{aligned}\n\\]\n    \n  \n\n\nPart 2 asks\n\nwhat is the fewest number of cubes of each color that could have been in the bag to make the game possible?\n\nThe word “fewest” might lead you to think we need to get the minimum. But actually, we need to find the maximum of each colour.\nLuckily, that’s precisely what we did in part 1. So we just need to multiply the largest of each colour and get the sum.\n\n\n\n\n\nimport math\n\n\nanswer2 = sum(math.prod(cubes) for cubes in max_cubes)\nprint(answer2)\n#&gt; 2286\n\n\n  Key Points\n  \n    \n\nWe already have the largest of each colour from part 1\nMultiply the largest of each colour and get the sum"
  },
  {
    "objectID": "posts/2023/02/2023-02.html#stocking-stuffers-candy-coated-comprehensions",
    "href": "posts/2023/02/2023-02.html#stocking-stuffers-candy-coated-comprehensions",
    "title": "2023 Day 2",
    "section": "Stocking Stuffers Candy-Coated Comprehensions",
    "text": "Stocking Stuffers Candy-Coated Comprehensions\nPretty much every line in the solution is a list comprehension. They can be combined to construct a juicy one-liner.\n\n[sum(l) for l in zip(*[(i * (cubes[0] &lt;= 12 and cubes[1] &lt;= 13 and cubes[2] &lt;= 14), math.prod(cubes)) for i, cubes in enumerate(([max(int(num) for num in re.findall(r'(\\d+) ' + c, line)) for c in ['red', 'green', 'blue']] for line in lines), 1)])]\n#&gt; [8, 2286]\n\n\n\n\n  \n  \n     Problem\n  \n\n  \n  \n     Input\n  \n\n  \n  \n     Full Solution\n  \n\n\n\n\n\n\n\n\n\n  2023 Day 2 Input\n  \n\n\n\nGame 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\nGame 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\nGame 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\nGame 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\nGame 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  2023 Day 2 Full Solution\n  \n\n\n\nimport math\nimport re\n\n\nwith open('input.txt', \"r\") as f:\n    lines = f.readlines()\n\n\ndef extract_cubes(line):\n    return [extract_max(line, color) for color in ['red', 'green', 'blue']]\n\n\ndef extract_max(line, c):\n    return max(int(num) for num in re.findall(r'(\\d+) ' + c, line))\n\n\nmax_cubes = [extract_cubes(line) for line in lines]\nanswer1 = sum(game_id for game_id, cubes in enumerate(max_cubes, 1) if cubes[0] &lt;= 12 and cubes[1] &lt;= 13 and cubes[2] &lt;= 14)\nprint(answer1)\n\n\n# Part 2\nanswer2 = sum(math.prod(cubes) for cubes in max_cubes)\nprint(answer2)\n\n\n\nExecution took 0.01 seconds"
  },
  {
    "objectID": "posts/2023/04/2023-04.html",
    "href": "posts/2023/04/2023-04.html",
    "title": "2023 Day 4",
    "section": "",
    "text": "Ho ho ho, fellow adventurers!\nIn Advent of Code day 4 we must convince an elf to lend us his boat by helping him decipher his scratchcards.\nThis puzzle propels us into the exciting world of dynamic programming, a technique for efficiently solving problems with overlapping subproblems. It’s our secret weapon against repetitive calculations!\nEven if you’re new to this, fear not! I’ll share an easy intuitive approach that will work with almost any dynamic programming challenge.\nFirst, we’ll read the input.\nwith open('input.txt', \"r\") as f:\n    lines = f.read().splitlines()"
  },
  {
    "objectID": "posts/2023/04/2023-04.html#part-1-multiplicative-match-mayhem",
    "href": "posts/2023/04/2023-04.html#part-1-multiplicative-match-mayhem",
    "title": "2023 Day 4",
    "section": "Part 1 Multiplicative Match Mayhem",
    "text": "Part 1 Multiplicative Match Mayhem\n\n\\[\n\\newcommand{\\grey}[1]{\\normalsize\\color{##969696}#1\\normalsize}\n\\]\n\\[\n\\newcommand{\\score}[1]{\\phantom{xxxxxxxx}\\llap{\\grey{#1}}}\n\\]\n\\[\n\\newcommand{\\plus}{\\smash{\\lower{0.5pc}\\color{#969696}{+}}}\n\\]\n\\[\n\\newcommand{\\card}[1]{\\text{Card #1: }}\n\\]\n\\[\n\\newcommand{\\num}[1]{\\large\\phantom{\\textbf{\\;1\\;\\;}}\\llap{\\text{\\;#1}}}\n\\]\n\\[\n\\newcommand{\\match}[1]{\\color{##2F7E4A}\\large\\phantom{\\textbf{\\;1\\;\\;}}\\llap{\\;\\textbf{#1}}\\color{##55595C}\\normalsize}\n\\]\n\\[\n\\newcommand{\\wins}[1]{\\phantom{xxx}\\llap{\\grey{\\text{#1}}}}\n\\]\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    Task 1\nCalculate the sum of scores of each card as one for the first match and double for each subsequent match.\n\nExample\n\n\\[\n\\begin{aligned}\n&\\card{1}\\num{41}\\match{48}\\match{83}\\match{86}\\match{17}\\;|\\match{83}\\match{86}\\num{ 6}\\num{31}\\match{17}\\num{ 9}\\match{48}\\num{53}&\\wins{4 wins}&&\\score{1 \\times 2 \\times 2 \\times 2}\\plus\\\\\n&\\card{2}\\num{13}\\match{32}\\num{20}\\num{16}\\match{61}\\;|\\match{61}\\num{30}\\num{68}\\num{82}\\num{17}\\match{32}\\num{24}\\num{19}&\\wins{2 wins}&&\\score{1 \\times 2}\\plus\\\\\n&\\card{3}\\match{ 1}\\match{21}\\num{53}\\num{59}\\num{44}\\;|\\num{69}\\num{82}\\num{63}\\num{72}\\num{16}\\match{21}\\num{14}\\match{ 1}&\\wins{2 wins}&&\\score{1 \\times 2}\\plus\\\\\n&\\card{4}\\num{41}\\num{92}\\num{73}\\match{84}\\num{69}\\;|\\num{59}\\match{84}\\num{76}\\num{51}\\num{58}\\num{ 5}\\num{54}\\num{83}&\\wins{1 wins}&&\\score{1}\\plus\\\\\n&\\card{5}\\num{87}\\num{83}\\num{26}\\num{28}\\num{32}\\;|\\num{88}\\num{30}\\num{70}\\num{12}\\num{93}\\num{22}\\num{82}\\num{36}&\\wins{0 wins}&&\\score{0}\\plus\\\\\n&\\card{6}\\num{31}\\num{18}\\num{13}\\num{56}\\num{72}\\;|\\num{74}\\num{77}\\num{10}\\num{23}\\num{35}\\num{67}\\num{36}\\num{11}&\\wins{0 wins}&&\\score{0}\\llap{\\lower{0.4pc}\\underline{\\phantom{\\large{\\textbf{13}}}}}\\phantom{\\plus}\\\\\n& & && \\color{#91672C}\\large{\\textbf{13}}\\normalsize\\phantom{\\plus}\n\\end{aligned}\n\\]\n  \n\n\n\n\n\nPart 1 is straightforward. We need to find the overlap of two sets and do some basic scoring.\nWe can parse out the left and right numbers into sets. Then the number of wins is just the length of the intersection of those sets.\n\nimport re\n\n\ncards = [[set(re.findall(r'\\d+', side)) for side in line.split(':')[1].split('|')] for line in lines]\nn_wins = [len(have.intersection(want)) for have, want in cards]\n\nThe score can be calculated as \\[\n\\begin{equation}\n\\text{score}(\\text{wins})=\n    \\begin{cases}\n        2^{\\text{wins} - 1} & \\text{if wins} \\gt 0\\\\\n        0 & \\text{otherwise}\n    \\end{cases}\n\\end{equation}\n\\]\n\nanswer1 = sum(2**(n - 1) for n in n_wins if n &gt; 0)\n\nPutting it all together\n\nimport re\n\n\ncards = [[set(re.findall(r'\\d+', side)) for side in line.split(':')[1].split('|')] for line in lines]\nn_wins = [len(have.intersection(want)) for have, want in cards]\nanswer1 = sum(2**(n - 1) for n in n_wins if n &gt; 0)\nprint(answer1)\n#&gt; 13\n\n\n  Key Points\n  \n    \n\nParse the left and right numbers into sets\nCalculate the number of wins as the length of the intersection of those sets\nCalculate the score based off the number of wins"
  },
  {
    "objectID": "posts/2023/04/2023-04.html#part-2-cutting-corners-caching-card-copies",
    "href": "posts/2023/04/2023-04.html#part-2-cutting-corners-caching-card-copies",
    "title": "2023 Day 4",
    "section": "Part 2 Cutting Corners Caching Card Copies",
    "text": "Part 2 Cutting Corners Caching Card Copies\n\n\n\n  \n    Task 2\nEach match wins copies of subsequent cards. Count all original cards and won copies to find the number of total cards.\n\nExample\n\nIn this example, there are 6 original cards and 24 won copies for a total of 30 cards.\n\\[\n\\begin{aligned}\n&\\card{1}\\num{41}\\match{48}\\match{83}\\match{86}\\match{17}\\;|\\match{83}\\match{86}\\num{ 6}\\num{31}\\match{17}\\num{ 9}\\match{48}\\num{53}&&\\grey{\\text{Wins cards 2, 3, 4, \\& 5}}\\\\\n&\\card{2}\\num{13}\\match{32}\\num{20}\\num{16}\\match{61}\\;|\\match{61}\\num{30}\\num{68}\\num{82}\\num{17}\\match{32}\\num{24}\\num{19}&&\\grey{\\text{Wins cards 3 \\& 4}}\\\\\n&\\card{3}\\match{ 1}\\match{21}\\num{53}\\num{59}\\num{44}\\;|\\num{69}\\num{82}\\num{63}\\num{72}\\num{16}\\match{21}\\num{14}\\match{ 1}&&\\grey{\\text{Wins cards 4 \\& 5}}\\\\\n&\\card{4}\\num{41}\\num{92}\\num{73}\\match{84}\\num{69}\\;|\\num{59}\\match{84}\\num{76}\\num{51}\\num{58}\\num{ 5}\\num{54}\\num{83}&&\\grey{\\text{Wins card 5}}\\\\\n&\\card{5}\\num{87}\\num{83}\\num{26}\\num{28}\\num{32}\\;|\\num{88}\\num{30}\\num{70}\\num{12}\\num{93}\\num{22}\\num{82}\\num{36}&&\\\\\n&\\card{6}\\num{31}\\num{18}\\num{13}\\num{56}\\num{72}\\;|\\num{74}\\num{77}\\num{10}\\num{23}\\num{35}\\num{67}\\num{36}\\num{11}&&\\\\\n\\end{aligned}\n\\]\n\n\n\n\n\n%%{\n  init: {\n    'theme': 'base',\n    'themeVariables': {\n      'primaryColor': '#55595c',\n      'primaryTextColor': '#55595c',\n      'primaryBorderColor': '#C2C2C2',\n      'lineColor': '#C2C2C2',\n      'secondaryColor': '#C2C2C2',\n      'tertiaryColor': '#fff',\n      'background': '#FFFFFF',\n      'mainBkg': '#FFFFFF',\n      'clusterBkg': '#ededed',\n      'fontFamily': 'Nunito Sans'\n    },\n    'flowchart': {\n      'nodeSpacing': 15,\n      'rankSpacing': 50\n    }\n  }\n}%%\nflowchart LR\n  A[Card 1]:::starting --&gt; A1[Card 2]\n  A[Card 1] --&gt; A2[Card 3]\n  A[Card 1] --&gt; A3[Card 4]\n  A[Card 1] --&gt; A4[Card 5]\n  A1 --&gt; A11[Card 3]\n  A1 --&gt; A12[Card 4]\n  A2 --&gt; A21[Card 4]\n  A2 --&gt; A22[Card 5]\n  A3[Card 4] --&gt; A31[Card 5]\n  A11 --&gt; A111[Card 4]\n  A11 --&gt; A112[Card 5]\n  A12[Card 4] --&gt; A121[Card 5]\n  A21[Card 4] --&gt; A211[Card 5]\n  A111[Card 4] --&gt; A1111[Card 5]\n\n  B[Card 2]:::starting --&gt; B1[Card 3]\n  B[Card 2] --&gt; B2[Card 4]\n  B1 --&gt; B11[Card 4]\n  B1 --&gt; B12[Card 5]\n  B11[Card 4] --&gt; B111[Card 5]\n  B2 --&gt; B21[Card 5]\n  \n  C[Card 3]:::starting --&gt; C1[Card 4]\n  C[Card 3] --&gt; C2[Card 5]\n  C1[Card 4] --&gt; C11[Card 5]\n  \n  D[Card 4]:::starting --&gt; D1[Card 5]\n  E[Card 5]:::starting\n  F[Card 6]:::starting\n  classDef default fill:#EDECFF\n  classDef starting fill:#FFF3BF\n\n\n\n\n\n\n  \n\n\n\nThe example can be solved by constructing the graph and counting the number of nodes. However, our full input would have millions of nodes - that wouldn’t be very efficient.\n\nSpotting Superfluous Subproblems Saves Seconds\nTo tackle this problem, we first need to identify that this is a dynamic programming problem. How do we know that?\nWell, how many subproblems do we need to solve in the example? Each node is a subproblem so there are 30 subproblems.\nNow, how many distinct subproblems are there? That is, how many distinct nodes are there? Only 6!\nThis leads us to conclude that this is a dynamic programming problem as there are overlapping subproblems.\n\n\nFrom Brute Force to Brilliance\nSo how can dynamic programming help us?\nRather than solving all 30 subproblems, we can just solve the 6 distinct subproblems and reuse those results. This saves us from repeating work we’ve already done.\n\n\nEffortless Efficiency\nSo now we know we need to use dynamic programming, but how do we do that? The thing is, unlike specific algorithms with defined steps, dynamic programming is a broad paradigm. There are multiple different ways to implement it.\nI’m going to share the easiest and most intuitive way to implement dynamic programming: recursion with memoisation\n\nStep 1: Recursion\nWrite the most naive and inefficient recursive solution you can come up with. Remember that a recursive function has two components:\n\nBase case\nRecursive case\n\n\ndef count_scratchcards(i):\n    # 1. Base case: If we win a card that doesn't exist\n    if i &gt; len(n_wins):\n        return 0\n  \n    # 2. Recursive case: The number of cards is this card (1) plus the sum of the next n cards\n    return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))\n\n\n\nStep 2: Memoisation\nOur recursive function essentially counts every node in the graph. To make it only execute computations for distinct nodes we just memoise the function! Memoisation is caching the results of a pure function.\nLuckily, this is just one line in python.\n\nimport functools\n\n\n@functools.cache # Memoisation\ndef count_scratchcards(i):\n    # 1. Base case: If we win a card that doesn't exist\n    if i &gt; len(n_wins):\n        return 0\n  \n    # 2. Recursive case: The number of cards is this card (1) plus the sum of the next n cards\n    return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))\n\nHere’s what this looks like showing calculated and cached nodes.\n\n\n\n\n\n%%{\n  init: {\n    'theme': 'base',\n    'themeVariables': {\n      'primaryColor': '#55595c',\n      'primaryTextColor': '#55595c',\n      'primaryBorderColor': '#C2C2C2',\n      'lineColor': '#C2C2C2',\n      'secondaryColor': '#C2C2C2',\n      'tertiaryColor': '#fff',\n      'background': '#FFFFFF',\n      'mainBkg': '#FFFFFF',\n      'clusterBkg': '#ededed',\n      'fontFamily': 'Nunito Sans'\n    },\n    'flowchart': {\n      'nodeSpacing': 15,\n      'rankSpacing': 50\n    }\n  }\n}%%\nflowchart LR\n  A[Card 1] --&gt; A1[Card 2]\n  A[Card 1] --&gt; A2[Card 3]:::cached\n  A[Card 1] --&gt; A3[Card 4]:::cached\n  A[Card 1] --&gt; A4[Card 5]:::cached\n  A1 --&gt; A11[Card 3]\n  A1 --&gt; A12[Card 4]:::cached\n  A11 --&gt; A111[Card 4]\n  A11 --&gt; A112[Card 5]:::cached\n  A111[Card 4] --&gt; A1111[Card 5]\n\n  X:::space\n  B[Card 2]:::cached\n  C[Card 3]:::cached  \n  D[Card 4]:::cached\n  E[Card 5]:::cached\n  F[Card 6]\n  classDef default fill:#EDECFF\n  classDef cached fill:#FFADAD\n  classDef space fill:white,color:white,stroke:white\n\n\n\n\n\n\n\n\n\n\n\n\nScratchy Solution Summarised\nOur final answer sums up all of the original cards.\n\nimport functools\n\n\n@functools.cache\ndef count_scratchcards(i):\n    if i &gt; len(n_wins):\n        return 0\n    return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))\n\n\nanswer2 = sum(count_scratchcards(i) for i in range(len(n_wins)))\nprint(answer2)\n#&gt; 30\n\n\n  Key Points\n  \n    \n\nUses dynamic programming via recursion with memoisation\ncount_scratchcards naively recursively counts the ith card\n\nBase case: If i exceeds the number of cards then there are 0 cards\nRecursive case: 1 (for the current card) plus the sum of subsequent cards\n\n@functools.cache memoises the function meaning it executes only a few hundred times instead of millions"
  },
  {
    "objectID": "posts/2023/04/2023-04.html#stocking-stuffers-dynamic-programming-for-dummies",
    "href": "posts/2023/04/2023-04.html#stocking-stuffers-dynamic-programming-for-dummies",
    "title": "2023 Day 4",
    "section": "Stocking Stuffers Dynamic Programming for Dummies",
    "text": "Stocking Stuffers Dynamic Programming for Dummies\nDynamic programming involves two steps:\n\nBreaking a problem down into subproblems.\nRecognising that many of these subproblems are equivalent. As we solve each subproblem, we record its answer. When we encounter a subproblem again, we simply retrieve its stored solution, avoiding wasteful recalculations.\n\n\n\n\n\n\n\nNote\n\n\n\nWhen you have 1 without 2, you are employing divide and conquer and not dynamic programming. E.g. quicksort and binary search.\n\n\nThis can be implemented in two ways:\n\nTop-down: Starts with the whole problem, breaks it down into smaller subproblems, and recursively solves them, storing solutions to reuse as needed.\nBottom-up: Starts with the smallest subproblems, solves them, and builds up to the larger problem, iteratively combining solutions until the whole problem is solved.\n\nLet’s use the most common example, the Fibonacci Numbers. They’re defined as \\[\n\\begin{equation}\nF_n =\n    \\begin{cases}\n        1 & \\text{if } n = 1 \\text{ or } n = 2\\\\\n        F_{n-1} + F_{n-2} & n \\gt 2\n    \\end{cases}\n\\end{equation}\n\\]\n\nTop-Down\nThe easiest way to implement top-down dynamic programming is recursion with memoisation\nWriting the problem recursively starts with the whole problem, breaks it down into smaller subproblems. Memoisation stores the solutions and reuses them as needed.\nThe mathematical definition directly translates to a recursive definition in python. Slap a @functools.cache on that bad boy and you’re done!\n\n@functools.cache\ndef fib(n):\n  if n in (1, 2):\n    return 1\n  return fib(n - 1) + fib(n - 2)\n\n\n\nBottom-Up\nWith bottom-up, we typically have an array that is conventionally called dp. We start with the smallest subproblem and build from there (fib(1), fib(2), ..., fib(n)).\n\ndef fib(n):\n  dp = [0] * (n + 1)\n  dp[1] = 1\n\n  for i in range(2, n + 1):\n    dp[i] = dp[i - 1] + dp[i - 2]\n\n  return dp[n]\n\n\n\n\n  \n  \n     Problem\n  \n\n  \n  \n     Input\n  \n\n  \n  \n     Full Solution\n  \n\n\n\n\n\n\n\n\n\n  2023 Day 4 Input\n  \n\n\n\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\nCard 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\nCard 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\nCard 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\nCard 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\nCard 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  2023 Day 4 Full Solution\n  \n\n\n\nimport functools\nimport re\n\n\nwith open(r'input.txt', \"r\") as f:\n    lines = f.read().splitlines()\n\n\ncards = [[set(re.findall(r'\\d+', side)) for side in line.split(':')[1].split('|')] for line in lines]\nn_wins = [len(have.intersection(want)) for have, want in cards]\nanswer1 = sum(2**(n - 1) for n in n_wins if n &gt; 0)\nprint(answer1)\n\n\n# Part 2\n@functools.cache\ndef count_scratchcards(i):\n  if i &gt; len(n_wins):\n    return 0\n  return 1 + sum(count_scratchcards(i + j + 1) for j in range(n_wins[i]))\n\n\nanswer2 = sum(count_scratchcards(i) for i in range(len(n_wins)))\nprint(answer2)\n\n\n\nExecution took 0.01 seconds"
  },
  {
    "objectID": "posts/2023/03/2023-03.html",
    "href": "posts/2023/03/2023-03.html",
    "title": "2023 Day 3",
    "section": "",
    "text": "Ho ho ho, fellow adventurers!\nGear up for a grid-based challenge. In Advent of Code day 3, we are tasked with deciphering engine schematics to fix a gondola lift.\nThis puzzle is trickier than the previous ones, but still manageable. It’s our first grid question and involves parsing numbers, getting adjacencies, and handling duplicates.\nFirst, we’ll read the input. Note that we use f.read().splitlines() instead of f.readlines() so our lines don’t include \\n.\nwith open('input.txt', \"r\") as f:\n    lines = f.read().splitlines()"
  },
  {
    "objectID": "posts/2023/03/2023-03.html#part-1-neighbourly-numbers",
    "href": "posts/2023/03/2023-03.html#part-1-neighbourly-numbers",
    "title": "2023 Day 3",
    "section": "Part 1 Neighbourly Numbers",
    "text": "Part 1 Neighbourly Numbers\n\n\n  \n    Task 1\nGet the sum of numbers neighbouring a symbol.\n\nExample\n\n\n\nFigure Source\nlibrary(tidyverse)\n\ndf &lt;-\n  read_lines(\"467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\"\n) |&gt;\n  str_split(\"\") |&gt;\n  map(enframe, name = \"col\") |&gt;\n  list_rbind(names_to = \"row\") |&gt;\n  mutate(\n    color = case_when(\n      value %in% c(\"*\", \"#\", \"+\", \"$\") ~ \"#BE4844\",\n      row == 1 & col &gt; 5 ~ \"#969696\",\n      row == 6 ~ \"#969696\",\n      !is.na(as.numeric(value)) ~ \"#2F7E4A\",\n      .default = \"#969696\"\n    ),\n    fontface = case_when(\n      color != \"#969696\" ~ \"bold\",\n      .default = \"plain\"\n    )\n  )\n\nadd &lt;- function(row, label, plus = TRUE, is_result = FALSE) {\n  component &lt;- annotate(\n    geom = \"text\",\n    x = 15,\n    y = row,\n    size = 7,\n    hjust = \"right\",\n    vjust = \"middle\",\n    color = ifelse(is_result, \"#91672C\", \"#969696\"),\n    fontface = ifelse(is_result, \"bold\", \"plain\"),\n    label = label,\n    family = \"LM Roman 10\"\n  )\n  if (plus) {\n    component &lt;- list(\n      component, \n      annotate(\n        geom = \"text\",\n        x = 15,\n        y = row + 0.5,\n        size = 6,\n        hjust = \"left\",\n        vjust = \"middle\",\n        color = \"#969696\",\n        label = \"+\",\n        family = \"LM Roman 10\"\n      )\n    )\n  }\n  component\n}\n\nneighbors &lt;- function(row, col, highlight = character()) {\n  draw_arrow &lt;- function(direction) {\n    dr &lt;- 0.55 * (str_detect(direction, \"S\") - str_detect(direction, \"N\"))\n    dc &lt;- 0.55 * (str_detect(direction, \"E\") - str_detect(direction, \"W\"))\n    if (dr != 0 && dc != 0) {\n      dr &lt;- dr * 0.8\n      dc &lt;- dc * 0.8\n    }\n    annotate(\n      geom = \"segment\",\n      x = col + dc,\n      xend = col + (dc * 1.00001),\n      y = row + dr,\n      yend = row + (dr * 1.00001),\n      #size = 1,\n      color = ifelse(direction %in% highlight, \"#1577A0\", \"#C2C2C2\"),\n      arrow = arrow(length = unit(0.015, \"npc\"), type = \"closed\")\n    )\n  }\n  map(c(\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\"), draw_arrow)\n}\n\ndf |&gt;\n  ggplot(aes(col, row, label = value, fontface = fontface, col = I(color))) +\n  geom_text(size = 7, family = \"LM Roman 10\") +\n  scale_y_reverse(\n    limits = c(12, 0),\n    expand = c(0, 0)\n  ) +\n  add(1, \"467\") +\n  add(3, \"35 + 633\") +\n  add(5, \"617\") +\n  add(7, \"592\") +\n  add(8, \"755\") +\n  add(10, \"664 + 598\", plus = FALSE) +\n  add(11, \"4361\", plus = FALSE, is_result = TRUE) +\n  neighbors(2, 4, c(\"S\", \"SW\", \"NW\")) +\n  neighbors(4, 7, c(\"N\", \"NE\")) +\n  neighbors(5, 4, c(\"W\")) +\n  neighbors(6, 6, c(\"SW\")) +\n  neighbors(9, 4, c(\"S\", \"SW\")) +\n  neighbors(9, 6, c(\"NE\", \"SE\", \"S\")) +\n  annotate(\n    geom = \"segment\",\n    x = 11.5,\n    xend = 15,\n    y = 10.5,\n    yend = 10.5,\n    color = \"#969696\"\n  ) +\n  theme_void()\n\n\n\n\n\n  \n\n\n\n\n\nIn part 1 we need to locate all the symbols and neighbouring numbers. Our approach is essentially this.\n\nfor each symbol:\n  get the 8 neighbouring numbers\n  remove duplicates\n  add the numbers to the answer\n\nRemoving duplicates is important. Consider the # symbol in the example. It is touching 633 to the north and touching it again to the north-east. We need to be mindful to not double-count.\nAlso, we want to be mindful to not accidentally under-count. Consider ..123*123.. where * has two distinct neighbours, 123 and 123. We want to only discard true duplicates.\n\nDigital Fingerprints\nWe’ll construct a dictionary, numbers, which maps every digit’s coordinate to its representation.\nnumbers = {\n  (0, 0): &lt;467&gt;,\n  (0, 1): &lt;467&gt;,\n  (0, 2): &lt;467&gt;,\n  (0, 5): &lt;114&gt;,\n  (0, 6): &lt;114&gt;,\n  (0, 7): &lt;114&gt;,\n  ...\n}\nWhat should the values of this dictionary be? It can’t just be the integer value as that wouldn’t necessarily uniquely identify each number.\nWe’re going to use re.finditer to get the start, end, and value of each number. We’ll do something sneaky and just use the re.Match objects as the values of numbers!\nIn the code below, match is a re.Match object which contains the start, end, and value a number. It uniquely identifies that number as each re.Match object has its own object ID - even if the string is identical.\n\nimport re\n\n\nnumbers = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'\\d+', line):\n        for col in range(match.start(), match.end()):\n            numbers[(row, col)] = match\n\n\n\nSymbol Surroundings\nWe want another dictionary, symbols, which maps every symbol’s coordinate to its character and neighbouring numbers.\nsymbols = {\n  (1, 3): ['*', [467, 35]],\n  (3, 6): ['#', [633]],\n  ...\n}\nAgain, we can get the symbol locations using re.finditer.\n\nsymbols = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'[^0-9.]', line):\n        symbols[(row, match.start())] = [match.group()]\n\nThen append the neighbours. Note that neighbours is constructed using set comprehension, so it is de-duplicated.\n\nfor (row, col), l in symbols.items():\n    neighbours = {numbers[(row + dr, col + dc)] for dr in range(-1, 2) for dc in range(-1, 2) if (row + dr, col + dc) in numbers}\n    l.append([int(match.group()) for match in neighbours])\n\n\n\nAssumption\nFinally, the answer is just the sum of all the neighbours.\nNote that this assumes that no number is neighbouring more than one symbol. If that were the case, it would be double-counted.\n\nanswer1 = sum(num for _, neighbours in symbols.values() for num in neighbours)\n\n\n\nSumming It Up\nNow, let’s put it all together.\n\nimport re\n\n\nnumbers = {}\nsymbols = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'\\d+', line):\n        for col in range(match.start(), match. end()):\n            numbers[(row, col)] = match\n    for match in re.finditer(r'[^0-9.]', line):\n        symbols[(row, match.start())] = [match.group()]\n\nfor (row, col), l in symbols.items():\n    neighbours = {numbers[(row + dr, col + dc)] for dr in range(-1, 2) for dc in range(-1, 2) if (row + dr, col + dc) in numbers}\n    l.append([int(match.group()) for match in neighbours])\n\nanswer1 = sum(num for _, neighbours in symbols.values() for num in neighbours)\nprint(answer1)\n#&gt; 4361\n\n\n  Key Points\n  \n    \n\nre.finditer locates the symbols and numbers\nThe numbers dictionary maps digit positions to their re.Match object\nThe symbols dictionary maps symbol positions to their character and a list of neighbouring integers\nThe answer is the sum of those integers\nThis solution assumes that a number has at most one symbol neighbour"
  },
  {
    "objectID": "posts/2023/03/2023-03.html#part-2-asterisk-adjacencies",
    "href": "posts/2023/03/2023-03.html#part-2-asterisk-adjacencies",
    "title": "2023 Day 3",
    "section": "Part 2 Asterisk Adjacencies",
    "text": "Part 2 Asterisk Adjacencies\n\n\n\n  \n    Task 2\n\nIdentify *s neighbouring exactly two numbers\nMultiply its two neighbours\nSum these values.\n\n\nExample\n\n\n\nFigure Source\nneighbors2 &lt;- function(row, col, highlight = character(), color = \"#1577A0\") {\n  draw_arrow &lt;- function(direction) {\n    dr &lt;- 0.55 * (str_detect(direction, \"S\") - str_detect(direction, \"N\"))\n    dc &lt;- 0.55 * (str_detect(direction, \"E\") - str_detect(direction, \"W\"))\n    if (dr != 0 && dc != 0) {\n      dr &lt;- dr * 0.8\n      dc &lt;- dc * 0.8\n    }\n    annotate(\n      geom = \"segment\",\n      x = col + dc,\n      xend = col + (dc * 1.00001),\n      y = row + dr,\n      yend = row + (dr * 1.00001),\n      color = color,\n      arrow = arrow(length = unit(0.015, \"npc\"), type = \"closed\")\n    )\n  }\n  map(highlight, draw_arrow)\n}\n\ndf |&gt;\n  mutate(\n    color = case_when(\n      row == 4 & col == 7 ~ \"#969696\",\n      row == 5 & col == 4 ~ \"#969696\",\n      row == 6 & col == 6 ~ \"#969696\",\n      row == 9 & col == 4 ~ \"#969696\",\n      \n      row == 3 & col &gt; 4 ~ \"#969696\",\n      row %in% c(5, 7) ~ \"#969696\",\n      row == 10 & col &lt;= 4 ~ \"#969696\",\n      .default = color\n    ),\n    fontface = case_when(\n      color != \"#969696\" ~ \"bold\",\n      .default = \"plain\"\n    )\n  ) |&gt;\n  ggplot(aes(col, row, label = value, fontface = fontface, col = I(color))) +\n  geom_text(size = 7, family = \"LM Roman 10\") +\n  scale_y_reverse(\n    limits = c(12, 0),\n    expand = c(0, 0)\n  ) +\n  add(2, expression(\"467 \" %*% \" 35\")) +\n  add(9, expression(\"755 \" %*% \" 598\"), plus = FALSE) +\n  add(11, \"467835\", plus = FALSE, is_result = TRUE) +\n  neighbors2(2, 4, c(\"S\", \"NW\")) +\n  neighbors2(4, 7, c(\"N\"), \"#C2C2C2\") +\n  neighbors2(5, 4, c(\"W\"), \"#C2C2C2\") +\n  neighbors2(6, 6, c(\"SW\"), \"#C2C2C2\") +\n  neighbors2(9, 4, c(\"S\"), \"#C2C2C2\") +\n  neighbors2(9, 6, c(\"NE\", \"S\")) +\n  annotate(\n    geom = \"segment\",\n    x = 11.3,\n    xend = 15,\n    y = 10.5,\n    yend = 10.5,\n    color = \"#969696\"\n  ) +\n  theme_void()\n\n\n\n\n\n  \n\n\nPart 2 tasks us with indentifying gears which are * symbols with exactly 2 neighbours.\nThis is straightforward as we have the symbols dictionary from part 1.\n\n\n\n\n\nimport math\n\n\nanswer2 = sum(math.prod(nums) for symbol, nums in symbols.values() if symbol == '*' and len(nums) == 2)\nprint(answer2)\n#&gt; 467835\n\n\n  Key Points\n  \n    \n\nFilter symbols where the symbol is * and the number of neighbours is 2\nGet the product of neighbours, then the sum"
  },
  {
    "objectID": "posts/2023/03/2023-03.html#stocking-stuffers-auspicious-assumptions",
    "href": "posts/2023/03/2023-03.html#stocking-stuffers-auspicious-assumptions",
    "title": "2023 Day 3",
    "section": "Stocking Stuffers Auspicious Assumptions",
    "text": "Stocking Stuffers Auspicious Assumptions\nOur solution assumes that no number is neighbouring more than one symbol. This is true of our input.\nTo make the solution more general and handle cases where numbers could neighbor multiple symbols, we’d need to adjust our approach to avoid potential double-counting. However, this makes the solution clunkier.\n\nimport math\nimport re\n\n\nnumbers = {}\nsymbols = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'\\d+', line):\n        for col in range(match.start(), match.end()):\n            numbers[(row, col)] = match\n    for match in re.finditer(r'[^0-9.]', line):\n        symbols[(row, match.start())] = [match.group()]\n\nfor (row, col), l in symbols.items():\n    neighbours = {numbers[(row + dr, col + dc)] for dr in range(-1, 2) for dc in range(-1, 2) if (row + dr, col + dc) in numbers}\n    l.append(neighbours)\n\npart_number_matches = set().union(*(neighbours for _, neighbours in symbols.values()))\nanswer1 = sum(int(match.group()) for match in part_number_matches)\nprint(answer1)\n#&gt; 4361\n\nanswer2 = sum(math.prod(int(match.group()) for match in matches) for symbol, matches in symbols.values() if symbol == '*' and len(matches) == 2)\nprint(answer2)\n#&gt; 467835\n\n\n  Key Points\n  \n    \n\nnumbers now stores its neighbours as a set of re.Match objects and not just a list of ints\nset().union(*l) will union all the sets in l\nThe matches are only converted to integers after de-duplication\nThis solution does not assume that a number has at most one symbol neighbour\n\n    \n  \n\nIt’s fine to tailor your solution to your input. While a general solution was possible for this problem, some days are practically impossible to solve in the general case and require crafting a solution specific to your input.\n\n\n\n  \n  \n     Problem\n  \n\n  \n  \n     Input\n  \n\n  \n  \n     Full Solution\n  \n\n\n\n\n\n\n\n\n\n  2023 Day 3 Input\n  \n\n\n\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  2023 Day 3 Full Solution\n  \n\n\n\nimport math\nimport re\n\n\nwith open(r'input.txt', \"r\") as f:\n    lines = f.read().splitlines()\n\n\nnumbers = {}\nsymbols = {}\nfor row, line in enumerate(lines):\n    for match in re.finditer(r'\\d+', line):\n        for col in range(match.start(), match. end()):\n            numbers[(row, col)] = match\n    for match in re.finditer(r'[^0-9.]', line):\n        symbols[(row, match.start())] = [match.group()]\n\nfor (row, col), l in symbols.items():\n    neighbours = {numbers[(row + dr, col + dc)] for dr in range(-1, 2) for dc in range(-1, 2) if (row + dr, col + dc) in numbers}\n    l.append([int(match.group()) for match in neighbours])\n\nanswer1 = sum(num for _, neighbours in symbols.values() for num in neighbours)\nprint(answer1)\n\n\n# Part 2\nanswer2 = sum(math.prod(nums) for symbol, nums in symbols.values() if symbol == '*' and len(nums) == 2)\nprint(answer2)\n\n\n\nExecution took 0.01 seconds"
  },
  {
    "objectID": "posts/2023/05/2023-05.html",
    "href": "posts/2023/05/2023-05.html",
    "title": "2023 Day 5",
    "section": "",
    "text": "Ho ho ho, fellow adventurers!\nIn Advent of Code day 5 we’re tasked with helping the gardener plant seeds and optimise food production.\nThis puzzle introduces us to interval mapping. We’re given a series of maps that define how values transition through different categories, like seeds to soil, soil to fertilizer, and so on. These maps use intervals to describe the conversion process.\nFirst, we’ll read the input.\nwith open('input.txt', \"r\") as f:\n    text = f.read()"
  },
  {
    "objectID": "posts/2023/05/2023-05.html#part-1-marvelous-maps",
    "href": "posts/2023/05/2023-05.html#part-1-marvelous-maps",
    "title": "2023 Day 5",
    "section": "Part 1 Marvelous Maps",
    "text": "Part 1 Marvelous Maps\n\n\n  \n    Task 1\nA series of mappings describe how values transition from Seed to Soil to Fertaliser to … to Location. Find the minimum location possible from a list of seed values.\n\nExample\n\n\n\nFigure Source\nlibrary(tidyverse)\n\n#| fig-width: 5\n#| fig-height: 4\ntext &lt;- \"seeds: 79 14 55 13\n\nseed-to-soil map:\n50 98 2\n52 50 48\n\nsoil-to-fertilizer map:\n0 15 37\n37 52 2\n39 0 15\n\nfertilizer-to-water map:\n49 53 8\n0 11 42\n42 0 7\n57 7 4\n\nwater-to-light map:\n88 18 7\n18 25 70\n\nlight-to-temperature map:\n45 77 23\n81 45 19\n68 64 13\n\ntemperature-to-humidity map:\n0 69 1\n1 0 69\n\nhumidity-to-location map:\n60 56 37\n56 93 4\"\n\nlines &lt;- str_split_1(text, \"\\n\\n\")\n\nseeds &lt;-\n  lines[[1]] |&gt;\n  str_extract_all(\"\\\\d+\", simplify = TRUE) |&gt;\n  as.numeric()\n\nsteps &lt;-\n  lines[-1] |&gt;\n  map(read_lines) |&gt;\n  map(\\(.) {\n    .[-1] |&gt;\n      str_extract_all(\"\\\\d+\", simplify = TRUE) |&gt;\n      as_tibble() |&gt;\n      set_names(c(\"dest_start\", \"source_start\", \"range_len\")) |&gt;\n      mutate(across(everything(), as.numeric))\n  })\n\nget_path &lt;- function(seed) {\n  value &lt;- seed\n  step &lt;- 1\n  path &lt;- list()\n  \n  while (step &lt;= length(steps)) {\n    dest &lt;-\n      steps[[step]] |&gt;\n      mutate(\n        is_valid = value &gt;= source_start & value &lt; source_start + range_len,\n        dest = dest_start + value - source_start\n      ) |&gt;\n      filter(value &gt;= source_start & value &lt; source_start + range_len) |&gt;\n      pull(dest)\n    \n    new_value &lt;- c(dest, value)[1]\n    path &lt;- bind_rows(\n      path,\n      tibble(\n        x = value,\n        xend = new_value,\n        y = 9 - step,\n        yend = y - 1\n      )\n    )\n    value = new_value\n    step &lt;- step + 1\n  }\n  path\n}\n\nplot_seeds &lt;- function(seeds) {\n  paths &lt;-\n  seeds |&gt;\n  map(get_path) |&gt;\n  list_rbind()\n\n  plot_df &lt;-\n    steps |&gt;\n    list_rbind(names_to = \"step\") |&gt;\n    mutate(\n      y = 9 - step,\n      yend = y - 1,\n      x = map2(source_start, range_len, \\(start, range) start + seq_len(range) - 1),\n      xend = map2(dest_start, range_len, \\(start, range) start + seq_len(range) - 1)\n    ) |&gt;\n    unnest()\n  \n  points &lt;-\n    bind_rows(\n      paths |&gt; select(x, y),\n      paths |&gt; select(x = xend, y = yend)\n    ) |&gt;\n    mutate(\n      col = case_when(\n        y == 8 ~ \"#2F7E4A\",\n        y == 1 & x == min(ifelse(y == 1, x, NA), na.rm = TRUE) ~ \"#91672C\",\n        TRUE ~ \"#1577A0\"\n      ),\n      size = ifelse(col == \"#1577A0\", 1.1, 3)\n    )\n  \n  ggplot(plot_df, aes(x, y, xend = xend, yend = yend)) +\n    geom_segment(alpha = 0.5, col = \"#969696\") +\n    geom_segment(data = paths, col = \"#1577A0\") +\n    geom_point(\n      data = points,\n      mapping = aes(x, y, col = I(col), size = I(size), xend = NULL, yend = NULL)\n    ) +\n    scale_y_continuous(\n      breaks = seq_len(8),\n      labels = rev(c(\"Seed\", \"Soil\", \"Fertilizer\", \"Water\", \"Light\", \"Temperature\", \"Humidity\", \"Location\"))\n    ) +\n    theme_void() +\n    theme(\n      axis.text.y = element_text(\n        family = \"LM Roman 10\",\n        margin = margin(r = 0.8 * 11 / 2),\n        hjust = 1\n      )\n    )\n}\n\n\nplot_seeds(seeds)\n\n\n\n\n\n  \n\n\n\n\n\nPart 1 is straightforward. Iterate through each initial seed. For each seed, go through all the conversion maps (soil, fertilizer, etc.). If the seed value falls within a defined range in a map, we convert it to the corresponding value in the destination category based on the formula dest_start + (seed - source_start). If the seed value doesn’t fall within any range in a map, it remains unchanged.\nAfter processing all the maps for a seed, we add its final converted value (which corresponds to the location category in the last map) to a list. Finally, we find the minimum value in the locations list.\n\nimport re\n\n\nseeds, *maps_list = text.split('\\n\\n')\nseeds = [int(x) for x in re.findall(r'\\d+', seeds)]\nmaps_list = [[[int(x) for x in re.findall(r'\\d+', line)] for line in maps.splitlines()[1:]] for maps in maps_list]\n\nlocations = []\nfor seed in seeds:\n    for maps in maps_list:\n        for dest_start, source_start, range_len in maps:\n            if source_start &lt;= seed &lt; source_start + range_len:\n                seed = dest_start + (seed - source_start)\n                break\n    locations.append(seed)\n\nanswer1 = min(locations)\nprint(answer1)\n#&gt; 35\n\n\n  Key Points\n  \n    \n\nMap each of the seeds from Soil to Fertaliser to … to Location\nAt each step find the range which overlaps with the current value and use it to map to the next step\nIf no range matches then the value moves unchanged to the next step\nGet the smallest Location"
  },
  {
    "objectID": "posts/2023/05/2023-05.html#part-2-intersecting-intervals",
    "href": "posts/2023/05/2023-05.html#part-2-intersecting-intervals",
    "title": "2023 Day 5",
    "section": "Part 2 Intersecting Intervals",
    "text": "Part 2 Intersecting Intervals\n\n\n\n  \n    Task 2\nGiven ranges of seed values find the minimum location possible.\n\nExample\n\n\n\nFigure Source\nseeds |&gt;\n  split(ceiling(seq_along(seeds) / 2)) |&gt;\n  map(\\(l) seq(l[1], l[1] + l[2])) |&gt;\n  unlist() |&gt;\n  plot_seeds()\n\n\n\n\n\n  \n\n\n\n\n\n\nAt first, this seems simple. Just update the list of seeds to contain all the seeds in the ranges. Unfortunately, there are billions of seeds so that would take several minutes.\nInstead of processing each individual seed within the initial ranges, we work directly with the ranges themselves. As we map these ranges through the conversion steps, we need to identify how they overlap with the ranges defined in each map. In some cases, this might involve splitting the initial range into smaller pieces\nOverlap detection and splitting will be simpler if we don’t have any gaps. So let’s fill in all the holes for all the maps.\n\ndef insert_missing_ranges(maps):\n    maps.sort(key=lambda e: e[1])\n    first_val = maps[0][1]\n    if first_val != 0:\n        maps.insert(0, [0, 0, first_val])\n    \n    last_val = maps[-1][1] + maps[-1][2]\n    maps.append([last_val, last_val, 10_000_000_000])\n\n    for i in range(len(maps) - 1):\n        end = maps[i][1] + maps[i][2]\n        start = maps[i+1][1]\n        if end != start:\n            maps.append((end, end, start - end))\n\n    maps.sort(key=lambda e: e[1])\n\nfor maps in maps_list:\n    insert_missing_ranges(maps)\n\nNow, map each of the ranges through all of the steps. If a range overlaps with a mapping range, map the overlapping portion and continue checkking the unmapped portion if there is any left.\n\ndef get_smallest_range(i, in_start, in_range_len):\n    if i == len(maps_list):\n        return in_start\n\n    output_ranges = [] # (out_start, out_range_len) pairs\n    for dest_start, source_start, range_len in maps_list[i]:\n        # No overlap\n        if source_start + range_len &lt;= in_start or source_start &gt;= in_start + in_range_len:\n            continue\n        \n        # Assume overlap\n        if source_start == in_start: # Source starts at input start\n            overlap_start = in_start\n            overlap_range_len = min(range_len, in_range_len)\n        elif source_start &lt; in_start: # Source starts to left\n            overlap_start = in_start\n            overlap_end = min(source_start + range_len, in_start + in_range_len)\n            overlap_range_len = overlap_end - in_start\n        else: # Source starts to right of input start\n            overlap_start = source_start\n            overlap_end = min(source_start + range_len, in_start + in_range_len)\n            overlap_range_len = overlap_end - source_start\n\n        overlap_start = overlap_start - source_start +  dest_start\n        output_ranges.append((overlap_start, overlap_range_len))\n\n    outputs = [get_smallest_range(i + 1, out_start, out_range_len) for out_start, out_range_len in output_ranges]\n    return min(outputs) if outputs else float('inf')\n\nstarting_ranges = [seeds[i:i+2] for i in range(0, len(seeds), 2)]\nanswer2 = min(get_smallest_range(0, in_start, in_range_len) for in_start, in_range_len in starting_ranges)\nprint(answer2)\n#&gt; 46\n\n\n  Key Points\n  \n    \n\nDon’t iterate over all possible seeds as that would take minutes\nInstead, maintain contiguous ranges at each step\nget_smallest_range will find the smallest location accessible in the ith step for the given range at that step\nIf the current range overlaps with a mapping range, map the overlapping portion and check the portion that doesn’t overlap\ninsert_missing_ranges ensures that the range 0 to 10 billion is fully covered by filling in missing ranges\nGuaranteeing no holes makes the overlap detection and splitting simpler\n\n    \n  \n\n\n\n\n  \n  \n     Problem\n  \n\n  \n  \n     Input\n  \n\n  \n  \n     Full Solution\n  \n\n\n\n\n\n\n\n\n\n  2023 Day 5 Input\n  \n\n\n\nseeds: 79 14 55 13\n\nseed-to-soil map:\n50 98 2\n52 50 48\n\nsoil-to-fertilizer map:\n0 15 37\n37 52 2\n39 0 15\n\nfertilizer-to-water map:\n49 53 8\n0 11 42\n42 0 7\n57 7 4\n\nwater-to-light map:\n88 18 7\n18 25 70\n\nlight-to-temperature map:\n45 77 23\n81 45 19\n68 64 13\n\ntemperature-to-humidity map:\n0 69 1\n1 0 69\n\nhumidity-to-location map:\n60 56 37\n56 93 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  2023 Day 5 Full Solution\n  \n\n\n\nimport re\n\n\nwith open('input.txt', \"r\") as f:\n    text = f.read()\n\n\nseeds, *maps_list = text.split('\\n\\n')\nseeds = [int(x) for x in re.findall(r'\\d+', seeds)]\nmaps_list = [[[int(x) for x in re.findall(r'\\d+', line)] for line in maps.splitlines()[1:]] for maps in maps_list]\n\nlocations = []\nfor seed in seeds:\n    for maps in maps_list:\n        for dest_start, source_start, range_len in maps:\n            if source_start &lt;= seed &lt; source_start + range_len:\n                seed = dest_start + (seed - source_start)\n                break\n    locations.append(seed)\n\nanswer1 = min(locations)\nprint(answer1)\n\n\n# Part 2\ndef insert_missing_ranges(maps):\n    maps.sort(key=lambda e: e[1])\n    first_val = maps[0][1]\n    if first_val != 0:\n        maps.insert(0, [0, 0, first_val])\n    \n    last_val = maps[-1][1] + maps[-1][2]\n    maps.append([last_val, last_val, 10_000_000_000])\n\n    for i in range(len(maps) - 1):\n        end = maps[i][1] + maps[i][2]\n        start = maps[i+1][1]\n        if end != start:\n            maps.append((end, end, start - end))\n\n    maps.sort(key=lambda e: e[1])\n\n\ndef get_smallest_range(i, in_start, in_range_len):\n    if i == len(maps_list):\n        return in_start\n\n    output_ranges = [] # (out_start, out_range_len) pairs\n    for dest_start, source_start, range_len in maps_list[i]:\n        # No overlap\n        if source_start + range_len &lt;= in_start or source_start &gt;= in_start + in_range_len:\n            continue\n        \n        # Assume overlap\n        if source_start == in_start: # Source starts at input start\n            overlap_start = in_start\n            overlap_range_len = min(range_len, in_range_len)\n        elif source_start &lt; in_start: # Source starts to left\n            overlap_start = in_start\n            overlap_end = min(source_start + range_len, in_start + in_range_len)\n            overlap_range_len = overlap_end - in_start\n        else: # Source starts to right of input start\n            overlap_start = source_start\n            overlap_end = min(source_start + range_len, in_start + in_range_len)\n            overlap_range_len = overlap_end - source_start\n\n        overlap_start = overlap_start - source_start +  dest_start\n        output_ranges.append((overlap_start, overlap_range_len))\n\n    outputs = [get_smallest_range(i + 1, out_start, out_range_len) for out_start, out_range_len in output_ranges]\n    return min(outputs) if outputs else float('inf')\n\n\nfor maps in maps_list:\n    insert_missing_ranges(maps)\n\nstarting_ranges = [seeds[i:i+2] for i in range(0, len(seeds), 2)]\nanswer2 = min(get_smallest_range(0, in_start, in_range_len) for in_start, in_range_len in starting_ranges)\nprint(answer2)\n\n\n\nExecution took 0.01 seconds"
  },
  {
    "objectID": "posts/2023/07/2023-07.html",
    "href": "posts/2023/07/2023-07.html",
    "title": "2023 Day 7",
    "section": "",
    "text": "\\[\n\\newcommand{\\blue}[1]{\\color{##1577A0}\\textbf{#1}\\color{##55595C}}\n\\newcommand{\\orange}[1]{\\color{##91672C}\\textbf{#1}\\color{##55595C}}\n\\newcommand{\\red}[1]{\\color{##BE4844}\\textbf{#1}\\color{##55595C}}\n\\newcommand{\\green}[1]{\\color{##2F7E4A}\\textbf{#1}\\color{##55595C}}\n\\newcommand{\\grey}[1]{\\color{##969696}{#1}\\color{##55595C}}\n\\newcommand{\\greyred}[1]{\\color{##f27d79}{#1}\\color{##55595C}}\n\\newcommand{\\greygreen}[1]{\\color{##7ec295}{#1}\\color{##55595C}}\n\\newcommand{\\greyblue}[1]{\\color{##76acc2}{#1}\\color{##55595C}}\n\\newcommand{\\plus}{\\smash{\\lower{0.5pc}\\grey{+}}}\n\\]\nHo ho ho, fellow adventurers!\nAdvent of Code day 7 invites us to play a game of Camel Cards. In this simplified version of poker, we must evaluate and rank hands.\nFirst, we’ll read the input.\nwith open(\"input.txt\", \"r\") as f:\n    lines = f.readlines()"
  },
  {
    "objectID": "posts/2023/07/2023-07.html#part-1-hand-hierarchy",
    "href": "posts/2023/07/2023-07.html#part-1-hand-hierarchy",
    "title": "2023 Day 7",
    "section": "Part 1 Hand Hierarchy",
    "text": "Part 1 Hand Hierarchy\n\n\n  \n    Task 1\nYou are given a list of 5 card hands and their corresponding bids. Rank each hand and calculate the winnings as the product of the rank and bid. Compute the total winnings.\nHands are ranked by their type. If two hands are of the same type, their ordering is then determined by comparing the strength of the individual cards, starting from the first card to the fifth, as needed.\nHand types are ranked as follows:\n\nHigh card\nOne pair\nTwo pair\nThree of a kind\nFull house\nFour of a kind\nFive of a kind\n\n\nExample\n\n\n\\[\n\\begin{aligned}\n&{\\text{Hand}} &&{\\text{Bid}} &&{\\text{\\grey{Rank}}} &&{\\text{\\grey{Type}}}\\phantom{\\Huge{g}}&{\\text{\\grey{Winnings}}} &\\\\\n&\\text{32T3K} &&\\green{765} &&\\greyblue{1} &&\\text{\\grey{One pair}}          &\\greygreen{765} \\,\\grey{\\times}\\, \\greyblue{1}                                                        &\\plus\\\\\n&\\text{T55J5} &&\\green{684} &&\\greyblue{4} &&\\text{\\grey{Full house}}        &\\greygreen{684} \\,\\grey{\\times}\\, \\greyblue{4}                                                        &\\plus\\\\\n&\\text{KK677} &&\\green{28}  &&\\greyblue{3} &&\\text{\\grey{Two pair}} & \\greygreen{28} \\,\\grey{\\times}\\, \\greyblue{3}                                                        &\\plus\\\\\n&\\text{KTJJT} &&\\green{220} &&\\greyblue{2} &&\\text{\\grey{Two pair}}\\grey{^*}          &\\greygreen{220} \\,\\grey{\\times}\\, \\greyblue{2}                                                        &\\plus\\\\\n&\\text{QQQJA} &&\\green{483} &&\\greyblue{5} &&\\text{\\grey{Three of a kind}}   &\\greygreen{483} \\,\\grey{\\times}\\, \\greyblue{5} \\llap{\\lower{0.4pc}\\underline{\\phantom{483 \\times 5}}} &\\\\\n&             &&            &&             &&                                &\\orange{6440}                                                                                         &\\\\\n\\end{aligned}\n\\]\n\\(\\grey{\\scriptsize{^{*}\\text{Second card ranks lower than other two pair's second card}}}\\)\n  \n\n\n\n\n\nWe’ll need a mechanism to rank hands. First, we define a function, primary_order, which ranks the hand’s type. This is accomplished by analysing the frequency of each card in the hand, allowing us to classify the hand based on predefined patterns.\n\nimport collections\n\n\ndef primary_order(hand):\n    counts = [count for card, count in collections.Counter(hand).most_common()]\n\n    possible_counts = [\n        [1, 1, 1, 1, 1],  # High card\n        [2, 1, 1, 1],  # One pair\n        [2, 2, 1],  # Two pair\n        [3, 1, 1],  # Three of a kind\n        [3, 2],  # Full house\n        [4, 1],  # Four of a kind\n        [5],  # Five of a kind\n    ]\n\n    return possible_counts.index(counts)\n\nNext, we define a function, secondary_order, which ranks hands based on the individual card values.\n\ndef secondary_order(hand, card_order=\"23456789TJQKA\"):\n    return tuple(card_order.index(card) for card in hand)\n\nFinally, define hand_bid_order as the combination of the primary and secondary orderings. Python makes it easy to combine and apply our primary and secondary orderings. We can provide sort a key function which takes an element and returns a tuple of the primary and secondary orderings.\nCalculate the total winnings as the sum of bids multiplied by the rank.\n\ndef hand_bid_order(hand_bid):\n    hand, bid = hand_bid\n    return primary_order(hand), secondary_order(hand)\n\n\nhands_bids = [line.split(\" \") for line in lines]\nhands_bids.sort(key=hand_bid_order)\nanswer1 = sum(i * int(bid) for i, (_, bid) in enumerate(hands_bids, 1))\nprint(answer1)\n#&gt; 6440\n\n\n  Key Points\n  \n    \n\nRanking Camel Cards hands involves two levels of ordering:\n\nPrimary ordering is based on the type of hand, determined by the pattern of card frequencies\nSecondary ordering evaluates the specific values of the cards within a hand\n\nA combined key function, hand_bid_order, uses both the primary and secondary orderings to sort the hands from weakest to strongest"
  },
  {
    "objectID": "posts/2023/07/2023-07.html#part-2-jokers-wild",
    "href": "posts/2023/07/2023-07.html#part-2-jokers-wild",
    "title": "2023 Day 7",
    "section": "Part 2 Jokers Wild",
    "text": "Part 2 Jokers Wild\n\n\n\n  \n    Task 2\nJs are now wild Jokers and act as whatever card results in the strongest type. Additionally, Jokers are now the weakest individual card.\nDetermine the new hand ranks and compute the total winnings.\n\nExample\n\n\\[\n\\begin{aligned}\n&{\\text{Hand}}      &&{\\text{Bid}} &&{\\text{\\grey{Rank}}} &&{\\text{\\grey{Type}}}\\phantom{\\Huge{g}}&{\\text{\\grey{Winnings}}} &\\\\\n&\\text{32T3K}       &&\\green{765} &&\\greyblue{1} &&\\text{\\grey{One pair}}          &\\greygreen{765} \\,\\grey{\\times}\\, \\greyblue{1}                                                        &\\plus\\\\\n&\\text{T55\\red{J}5} &&\\green{684} &&\\greyblue{3} &&\\text{\\grey{Four of a kind}}        &\\greygreen{684} \\,\\grey{\\times}\\, \\greyblue{3}                                                        &\\plus\\\\\n&\\text{KK677}       &&\\green{28}  &&\\greyblue{2} &&\\text{\\grey{Two pair}} & \\greygreen{28} \\,\\grey{\\times}\\, \\greyblue{2}                                                        &\\plus\\\\\n&\\text{KT\\red{JJ}T} &&\\green{220} &&\\greyblue{5} &&\\text{\\grey{Four of a kind}}          &\\greygreen{220} \\,\\grey{\\times}\\, \\greyblue{5}                                                        &\\plus\\\\\n&\\text{QQQ\\red{J}A} &&\\green{483} &&\\greyblue{4} &&\\text{\\grey{Four of a kind}}   &\\greygreen{483} \\,\\grey{\\times}\\, \\greyblue{4} \\llap{\\lower{0.4pc}\\underline{\\phantom{483 \\times 4}}} &\\\\\n&                   &&            &&             &&                                &\\orange{5905}                                                                                         &\\\\\n\\end{aligned}\n\\]\n  \n\n\n\n\n\n\nCreate a new function, hand_bid_order_wild, which evaluates the maximum potential strength of a hand by considering all possible substitutions of J with other cards.\nUpdate the card order for secondary_order such that Jokers are the weakest.\n\ndef hand_bid_order_wild(hand_bid):\n    hand, bid = hand_bid\n    return (\n        max(primary_order(hand.replace(\"J\", c)) for c in \"23456789TQKA\"),\n        secondary_order(hand, \"J23456789TQKA\"),\n    )\n\n\nhands_bids.sort(key=hand_bid_order_wild)\nanswer2 = sum(i * int(bid) for i, (_, bid) in enumerate(hands_bids, 1))\nprint(answer2)\n#&gt; 5905\n\n\n  Key Points\n  \n    \n\nCompute the max primary_order when replacing Js with every other card\nUpdate the card order for secondary_order such that Jokers are the weakest\n\n    \n  \n\n\n\n\n  \n  \n     Problem\n  \n\n  \n  \n     Input\n  \n\n  \n  \n     Full Solution\n  \n\n\n\n\n\n\n\n\n\n  2023 Day 7 Input\n  \n\n\n\n32T3K 765\nT55J5 684\nKK677 28\nKTJJT 220\nQQQJA 483\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  2023 Day 7 Full Solution\n  \n\n\n\nimport collections\n\n\nwith open(\"input.txt\", \"r\") as f:\n    lines = f.read().splitlines()\n\n\ndef primary_order(hand):\n    counts = [count for card, count in collections.Counter(hand).most_common()]\n\n    possible_counts = [\n        [1, 1, 1, 1, 1],  # High card\n        [2, 1, 1, 1],  # One pair\n        [2, 2, 1],  # Two pair\n        [3, 1, 1],  # Three of a kind\n        [3, 2],  # Full house\n        [4, 1],  # Four of a kind\n        [5],  # Five of a kind\n    ]\n\n    return possible_counts.index(counts)\n\n\ndef secondary_order(hand, card_order=\"23456789TJQKA\"):\n    return tuple(card_order.index(card) for card in hand)\n\n\ndef hand_bid_order(hand_bid):\n    hand, bid = hand_bid\n    return primary_order(hand), secondary_order(hand)\n\n\nhands_bids = [line.split(\" \") for line in lines]\nhands_bids.sort(key=hand_bid_order)\nanswer1 = sum(i * int(bid) for i, (_, bid) in enumerate(hands_bids, 1))\nprint(answer1)\n\n\n# Part 2\ndef hand_bid_order_wild(hand_bid):\n    hand, bid = hand_bid\n    return (\n        max(primary_order(hand.replace(\"J\", c)) for c in \"23456789TQKA\"),\n        secondary_order(hand, \"J23456789TQKA\"),\n    )\n\n\nhands_bids.sort(key=hand_bid_order_wild)\nanswer2 = sum(i * int(bid) for i, (_, bid) in enumerate(hands_bids, 1))\nprint(answer2)\n\n\n\nExecution took 0.01 seconds"
  },
  {
    "objectID": "posts/2023/01/2023-01.html",
    "href": "posts/2023/01/2023-01.html",
    "title": "2023 Day 1",
    "section": "",
    "text": "Ho ho ho, fellow adventurers!\nAdvent of Code day 1 has catapulted us into a realm of medieval engineering. Day 1 starts off easy with string manipulation.\nI narrowly missed the Part 1 leaderboard, landing at rank 119. Just 4 seconds faster and I’d have cracked the top 100.\nFirst, we’ll read the input.\nwith open('input.txt', \"r\") as f:\n    lines = f.readlines()"
  },
  {
    "objectID": "posts/2023/01/2023-01.html#part-1-trebuchet-trouble",
    "href": "posts/2023/01/2023-01.html#part-1-trebuchet-trouble",
    "title": "2023 Day 1",
    "section": "Part 1 Trebuchet Trouble",
    "text": "Part 1 Trebuchet Trouble\n\n\\[\n% \\underline doesn't support thickness, so I just redraw the underline slightly offset three times\n\\newcommand{\\thickul}[2]{%\n\\large{\\textbf{#2}}%\n\\color{#1}%\n\\llap{\\underline{\\phantom{\\large{\\textbf{#2}}}}}%\n\\llap{\\underline{\\lower{.05ex}\\phantom{\\large{\\textbf{#2}}}}}%\n\\llap{\\underline{\\lower{.1ex}\\phantom{\\large{\\textbf{#2}}}}}%\n\\llap{\\underline{\\lower{.15ex}\\phantom{\\large{\\textbf{#2}}}}}%\n\\color{##55595C}\\normalsize%\n}\n\\]\n\\[\n\\newcommand{\\first}[1]{\\thickul{##2F7E4A}{#1}}\n\\]\n\\[\n\\newcommand{\\last}[1]{\\thickul{##1577A0}{#1}}\n\\]\n\\[\n\\newcommand{\\both}[1]{%\n\\thickul{##2F7E4A}{#1}%\n\\color{##1577A0}%\n\\llap{\\underline{\\lower{1ex}\\phantom{\\large{\\textbf{#1}}}}}%\n\\llap{\\underline{\\lower{1.05ex}\\phantom{\\large{\\textbf{#1}}}}}%\n\\llap{\\underline{\\lower{1.1ex}\\phantom{\\large{\\textbf{#1}}}}}%\n\\llap{\\underline{\\lower{1.15ex}\\phantom{\\large{\\textbf{#1}}}}}%\n\\color{##55595C}\\normalsize%\n}\n\\]\n\n\n\n\n  \n    Task 1\n    \nCombine the first and last digit of each string and get the sum.\n\nExample\n\n\\[\n\\begin{aligned}\n\\first{1}\\text{abc}\\last{2} & ~~~~~ & \\color{#969696}12 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\text{pqr}\\first{3}\\text{stu}\\last{8}\\text{vwx} & & \\color{#969696}38 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\text{a}\\first{1}\\text{b2c3d4e}\\last{5}\\text{f} & & \\color{#969696}15 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\text{treb}\\both{7}\\text{uchet} & & \\color{#969696}77\\llap{\\lower{0.4pc}\\underline{\\phantom{\\large{\\textbf{142}}}}} & \\\\\n& & \\color{#91672C}\\large{\\textbf{142}} &\\\\\n\\end{aligned}\n\\]\n    \n  \n\n\nIn part 1, we need to get the trebuchet calibration values by extracting the first and last digits of each line of the input.\nThis can be done with regex, but instead I’ll iterate through each letter until I find a digit.\n\n\n\n\n\ndef first_value(line, m):\n  for i, _ in enumerate(line):\n    for text, val in m.items():\n      if line[i:].startswith(text):\n        return val\n\n\nm = {c: int(c) for c in '123456789'}\n\nanswer1 = sum(10 * first_value(line, m) + first_value(line[::-1], m) for line in lines)\nprint(answer1)\n#&gt; 142\n\n\n  Key Points\n  \n    \n\nm maps digit characters to their integer values\nfirst_value finds the first substring that starts with any key of m and returns its value\nThe string is reversed to find the last value"
  },
  {
    "objectID": "posts/2023/01/2023-01.html#part-2-spelling-everything-with-letters",
    "href": "posts/2023/01/2023-01.html#part-2-spelling-everything-with-letters",
    "title": "2023 Day 1",
    "section": "Part 2 Spelling Everything with Letters",
    "text": "Part 2 Spelling Everything with Letters\n\n\n\n  \n    Task 2\n    \nAdapt part 1 to handle digits spelled out with letters.\n\nExample\n\n\\[\n\\begin{aligned}\n\\first{two}\\text{1}\\last{nine} & ~~~~~ & \\color{#969696}29 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\first{eight}\\text{wo}\\last{three} & & \\color{#969696}83 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\text{abc}\\first{one}\\text{2}\\last{three}\\text{xyz} & & \\color{#969696}13 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\text{x}\\first{two}\\text{ne3}\\last{four} & & \\color{#969696}24 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\first{4}\\text{nineeightseven}\\last{2} & & \\color{#969696}42 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\text{z}\\first{one}\\text{ight23}\\last{4} & & \\color{#969696}14 & \\smash{\\lower{0.5pc}\\color{#969696}+}\\\\\n\\first{7}\\text{pqrst}\\last{six}\\text{teen} & & \\color{#969696}76\\llap{\\lower{0.4pc}\\underline{\\phantom{\\large{\\textbf{281}}}}} & \\\\\n& & \\color{#91672C}\\large{\\textbf{281}} &\\\\\n\\end{aligned}\n\\]\n    \n  \n\n\nNow, we need to handle digits spelled out with letters. We’ll update m with these new mappings.\nHowever, now that m contains keys with more than one letter it won’t work when the string is reversed. For example, it needs to match eno instead of one.\nSo we’ll create rev_m with each key reversed.\n\n\n\n\n\nwords = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\nm.update({text: i for i, text in enumerate(words, 1)})\nrev_m = {text[::-1]: value for text, value in m.items()}\n\nanswer2 = sum(10 * first_value(line, m) + first_value(line[::-1], rev_m) for line in lines)\nprint(answer2)\n#&gt; 281\n\n\n  Key Points\n  \n    \n\nm has been extended to include mappings for digits spelled out with letters (e.g. {'one': 1, 'two': 2, ...}).\nrev_m is m with each key reversed (e.g. {'eno': 1, 'owt': 2, ...})\nThe first digit is extracted using m, while the last digit uses rev_m\n\n    \n  \n\n\n\n\n  \n  \n     Problem\n  \n\n  \n  \n     Input\n  \n\n  \n  \n     Full Solution\n  \n\n\n\n\n\n\n\n\n\n  2023 Day 1 Input\n  \n\n\n\n1abc2\npqr1stu8vwx\na1b2c3d4e5f\ntreb1uchet\nfive1eight\neightwo1three\nabcone1threexyz\nxtwone1four\n1nineeightseven7\nzoneight134\n1pqrstsixteen\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  2023 Day 1 Full Solution\n  \n\n\n\nwith open('input.txt', \"r\") as f:\n    lines = f.readlines()\n\n\ndef first_value(line, m):\n  for i, _ in enumerate(line):\n    for text, val in m.items():\n      if line[i:].startswith(text):\n        return val\n\n\nm = {c: int(c) for c in '123456789'}\n\nanswer1 = sum(10 * first_value(line, m) + first_value(line[::-1], m) for line in lines)\nprint(answer1)\n\n\n# Part 2\nwords = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\nm.update({text: i for i, text in enumerate(words, 1)})\nrev_m = {text[::-1]: value for text, value in m.items()}\n\nanswer2 = sum(10 * first_value(line, m) + first_value(line[::-1], rev_m) for line in lines)\nprint(answer2)\n\n\n\nExecution took 0.01 seconds"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Paul Foster - Advent of Code",
    "section": "",
    "text": "2023 Day 8\n\n\nHaunted Wasteland\n\n\n\n\npython\n\n\nmedium\n\n\ngraph\n\n\ncycles\n\n\ninput-specific\n\n\n\n\nMedium graph puzzle involving cycles.\n\n\n\n\n\n\nApr 13, 2024\n\n\nPaul Foster\n\n\n\n\n\n\n  \n\n\n\n\n2023 Day 7\n\n\nCamel Cards\n\n\n\n\npython\n\n\neasy\n\n\n\n\nEasy puzzle evaluating simplified poker hands.\n\n\n\n\n\n\nApr 3, 2024\n\n\nPaul Foster\n\n\n\n\n\n\n  \n\n\n\n\n2023 Day 6\n\n\nWait For It\n\n\n\n\npython\n\n\neasy\n\n\nmathematics\n\n\n\n\nEasy mathematics puzzle.\n\n\n\n\n\n\nMar 30, 2024\n\n\nPaul Foster\n\n\n\n\n\n\n  \n\n\n\n\n2023 Day 5\n\n\nIf You Give A Seed A Fertilizer\n\n\n\n\npython\n\n\nmedium\n\n\nintervals\n\n\n\n\nMedium difficulty intervals puzzle.\n\n\n\n\n\n\nMar 29, 2024\n\n\nPaul Foster\n\n\n\n\n\n\n  \n\n\n\n\n2023 Day 4\n\n\nScratchcards\n\n\n\n\npython\n\n\nmedium\n\n\ndynamic programming\n\n\n\n\nMedium difficulty dynamic programming puzzle.\n\n\n\n\n\n\nJan 6, 2024\n\n\nPaul Foster\n\n\n\n\n\n\n  \n\n\n\n\n2023 Day 3\n\n\nGear Ratios\n\n\n\n\npython\n\n\nmedium\n\n\n\n\nMedium difficulty grid puzzle involving parsing numbers, getting adjacencies, and handling duplicates.\n\n\n\n\n\n\nJan 4, 2024\n\n\nPaul Foster\n\n\n\n\n\n\n  \n\n\n\n\n2023 Day 2\n\n\nCube Conundrum\n\n\n\n\npython\n\n\neasy\n\n\n\n\nEasy puzzle with basic regex and arithmetic.\n\n\n\n\n\n\nJan 3, 2024\n\n\nPaul Foster\n\n\n\n\n\n\n  \n\n\n\n\n2023 Day 1\n\n\nTrebuchet?!\n\n\n\n\npython\n\n\neasy\n\n\n\n\nEasy string manipulation.\n\n\n\n\n\n\nJan 1, 2024\n\n\nPaul Foster\n\n\n\n\n\n\nNo matching items"
  }
]